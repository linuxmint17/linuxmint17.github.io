<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GPG export import Keys</title>
    <url>/2022/03/23/GPG-export-import-Keys/</url>
    <content><![CDATA[<ul>
<li><p>列出本地的所有 Key<br>执行 gpg –list-keys 列出本地所有的密钥<br>输出结果类似</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> $ gpg --list-keys</span><br><span class="line"> /home/<span class="variable">$USER</span>/.gnupg/pubring.gpg</span><br><span class="line">--------------------------------</span><br><span class="line">pub   4 096R/375A500B 2017-03-22 [有效至：2018-03-22]</span><br><span class="line">uid                  Goren G (Git) &lt;gythialy.koo+git@gmail.com&gt;</span><br><span class="line">sub   4096R/ADB9D36C 2017-03-22 [有效至：2018-03-22]</span><br></pre></td></tr></table></figure></li>
<li><p>导出<br>根据 375A500B 导出相应的公钥和私钥</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --output mygpgkey_pub.gpg --armor --<span class="built_in">export</span> 375A500B</span><br><span class="line">gpg --output mygpgkey_sec.gpg --armor --export-secret-key 375A500B</span><br></pre></td></tr></table></figure></li>
<li><p>导入<br>导入刚导入的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --import ~/mygpgkey_pub.gpg</span><br><span class="line">gpg --allow-secret-key-import --import ~/mygpgkey_sec.gpg</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除密码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --edit-key 375A500B</span><br><span class="line"><span class="comment"># 在弹出的界面中输入原来密码，新密码留空即可</span></span><br><span class="line">passwd</span><br><span class="line"><span class="comment"># 保存修改</span></span><br><span class="line">save</span><br></pre></td></tr></table></figure>
<p>【转载】<br><a href="https://gythialy.github.io/Howto-import-export-gpg-key/">https://gythialy.github.io/Howto-import-export-gpg-key/</a></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>C++ 11/14/17/20 new feature</title>
    <url>/2020/05/24/about-C-Cpp-new-feature/</url>
    <content><![CDATA[<h1 id="自从C-11以来的新特性"><a href="#自从C-11以来的新特性" class="headerlink" title="自从C++11以来的新特性"></a>自从C++11以来的新特性</h1><ul>
<li>auto 自动类型推导</li>
<li>constexpr</li>
<li>nullptr 关键字, 用于取代 NULL, 代表空指针</li>
<li>for 循环中的 语法糖 for ( a : array) { }</li>
<li>lambda 表达式， 也就是匿名函数</li>
</ul>
<h1 id="自从C99以来的新特性"><a href="#自从C99以来的新特性" class="headerlink" title="自从C99以来的新特性"></a>自从C99以来的新特性</h1><ul>
<li>变长数组 VLA;</li>
<li>结构体 按成员初始化</li>
<li>restrict 关键字</li>
<li>bool 类型</li>
</ul>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>About IPC</title>
    <url>/2020/03/29/about-IPC/</url>
    <content><![CDATA[<h1 id="IPC-Inter-Porcess-Communication-进程间通信"><a href="#IPC-Inter-Porcess-Communication-进程间通信" class="headerlink" title="IPC (Inter-Porcess Communication) 进程间通信"></a>IPC (Inter-Porcess Communication) 进程间通信</h1><p>　　多个进程需要协作的时候通信必不可少</p>
<h1 id="IPC-的五种基本方法"><a href="#IPC-的五种基本方法" class="headerlink" title="IPC 的五种基本方法"></a>IPC 的五种基本方法</h1><ol>
<li>Pipes &#x2F; FIFOs 管道</li>
<li>Message Queues 消息队列</li>
<li>Shared Memory 共享内存</li>
<li>POSIX Semaphores POSIX 信号量</li>
<li>Sockets 套接字<h2 id="Pipes-的特性"><a href="#Pipes-的特性" class="headerlink" title="Pipes 的特性"></a>Pipes 的特性</h2></li>
<li>兼容性问题：最早的时候都是半双工，有的系统却提供了全双工的管道</li>
<li>适用范围的问题：只能在具有相同的祖先进程的进程间使用，多数情况是在父子进程之间使用<h3 id="Pipes-的使用"><a href="#Pipes-的使用" class="headerlink" title="Pipes 的使用"></a>Pipes 的使用</h3>　　使用pipe需要了解两个函数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要包含头文件 &lt;unistd.h&gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pipe</span><span class="params">(<span class="type">int</span> fd[<span class="number">2</span>])</span></span>; <span class="comment">// 创建两个文件描述符，fd[0] 用于读取，fd[1]用于写入</span></span><br><span class="line"><span class="comment">// 需要包含头文件 &lt;unistd.h&gt; 和 &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">// 通过复制父进程创建子进程</span></span><br><span class="line"><span class="comment">// 标准头文件 &lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">// The  popen() function opens a process by creating a pipe, forking,</span></span><br><span class="line"><span class="comment">// and invoking the shell</span></span><br><span class="line"><span class="function">FILE *<span class="title">popen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *command, <span class="type">const</span> <span class="type">char</span> *type)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pclose</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下代码对 APUE 中的代码做了简化和改动</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLINE 4096</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line">    <span class="type">char</span> line[MAXLINE];</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">pipe</span>(fd) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;pipe create error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fork child error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123; <span class="comment">// 父进程</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">write</span>(fd[<span class="number">1</span>], <span class="string">&quot;Hello child\n&quot;</span>, <span class="built_in">sizeof</span>(<span class="string">&quot;Hello child\n&quot;</span>) - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;write some thing inside %u\n&quot;</span>, <span class="built_in">getpid</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 子进程</span></span><br><span class="line">        <span class="built_in">close</span>(fd[<span class="number">1</span>]);</span><br><span class="line">        n = <span class="built_in">read</span>(fd[<span class="number">0</span>], line, MAXLINE);</span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO, line, n); </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read some thing from %u\n&quot;</span>, <span class="built_in">getppid</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Message-Queues-的特性"><a href="#Message-Queues-的特性" class="headerlink" title="Message Queues 的特性"></a>Message Queues 的特性</h2><h2 id="Message-Queues-的使用"><a href="#Message-Queues-的使用" class="headerlink" title="Message Queues 的使用"></a>Message Queues 的使用</h2><h2 id="Shared-Memory-的特性"><a href="#Shared-Memory-的特性" class="headerlink" title="Shared Memory 的特性"></a>Shared Memory 的特性</h2><p>  共享内存不提供同步机制，user需要使用消息队列，信号量或者sockets提供的消息机制</p>
<h2 id="Shared-Memory-的使用"><a href="#Shared-Memory-的使用" class="headerlink" title="Shared Memory 的使用"></a>Shared Memory 的使用</h2><h2 id="POSIX-Semaphores-的特性"><a href="#POSIX-Semaphores-的特性" class="headerlink" title="POSIX Semaphores 的特性"></a>POSIX Semaphores 的特性</h2><h2 id="POSIX-Semaphores-的使用"><a href="#POSIX-Semaphores-的使用" class="headerlink" title="POSIX Semaphores 的使用"></a>POSIX Semaphores 的使用</h2><h2 id="Sockets-的特性"><a href="#Sockets-的特性" class="headerlink" title="Sockets 的特性"></a>Sockets 的特性</h2><h2 id="Sockets-的使用"><a href="#Sockets-的使用" class="headerlink" title="Sockets 的使用"></a>Sockets 的使用</h2>]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>about-Qt</title>
    <url>/2020/03/31/about-Qt/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>About Algorithm</title>
    <url>/2020/01/21/about-algorithm/</url>
    <content><![CDATA[<h2 id="关于算法的思考"><a href="#关于算法的思考" class="headerlink" title="关于算法的思考"></a>关于算法的思考</h2><pre><code>算法出现的比计算机要早很多:比如说 最大公约数(Greatest common divisor 简写为GCD)的求法,早在
</code></pre>
<p>公元前300年出版的《几何原本》中已经有算法，至今仍然是很实用的方法.</p>
<h2 id="算法我之见"><a href="#算法我之见" class="headerlink" title="算法我之见"></a>算法我之见</h2><p>   我的看法就是求解某类或者某个问题的固定方法：按照方法做就一定能在有限的时间内得到结果.<br>算法要理解必须有自己的思路，否则当时学会或者记住了，过一阵子就会忘记(记忆天才除外吧).</p>
<h2 id="算法学习-x2F-推导的过程"><a href="#算法学习-x2F-推导的过程" class="headerlink" title="算法学习&#x2F;推导的过程"></a>算法学习&#x2F;推导的过程</h2><pre><code>把自己思路教给计算机,使用计算机的语言准确描述描述。
将你的想法交给计算机去执行，首先要了解一个算法手动是怎样计算的，
</code></pre>
<p>手动推演两到三步然后归纳出规律，使用while和if将你的想法写出来伪代码(伪代码甚至可以有一些逻辑错误)，<br>有一点小错误，不要紧，<br>    然后开始将伪代码转为C++代码，调试各种特殊情况和一般情况(测试)<br>    最后自己的(烂)算法大功告成，进行优化和分析确保逻辑上不会有大漏洞</p>
<h2 id="推演的技巧"><a href="#推演的技巧" class="headerlink" title="推演的技巧"></a>推演的技巧</h2><pre><code>可以从简单的情况入手,尝试解决问题保证自己理解了算法的需求背景，
</code></pre>
<p>特殊推导一般(情形越特殊越简单,高中数学老师讲的),代码中可能有专门用于特殊情况处理的if分支可以考虑<br>是否可以用一般涵盖特殊;</p>
]]></content>
  </entry>
  <entry>
    <title>About Bash</title>
    <url>/2020/02/14/about-bash/</url>
    <content><![CDATA[<h2 id="Bash的环境变量"><a href="#Bash的环境变量" class="headerlink" title="Bash的环境变量"></a>Bash的环境变量</h2><ul>
<li>PROMPT_DIRTRIM<br>修改PS1中dir的个数 trim 留下几层目录<h2 id="bashrc-检查错误"><a href="#bashrc-检查错误" class="headerlink" title="bashrc 检查错误"></a>bashrc 检查错误</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ bash -n ~/.bashrc</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>about build tool/system</title>
    <url>/2021/09/05/about-build-tools/</url>
    <content><![CDATA[<h1 id="了解过的构建工具"><a href="#了解过的构建工具" class="headerlink" title="了解过的构建工具"></a>了解过的构建工具</h1><h1 id="Make-Cmake"><a href="#Make-Cmake" class="headerlink" title="Make Cmake"></a>Make Cmake</h1><h1 id="Gradle-Ant"><a href="#Gradle-Ant" class="headerlink" title="Gradle Ant"></a>Gradle Ant</h1><h1 id="Ninjia-GN"><a href="#Ninjia-GN" class="headerlink" title="Ninjia GN"></a>Ninjia GN</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>about bus</title>
    <url>/2021/09/04/about-bus/</url>
    <content><![CDATA[<h1 id="总线"><a href="#总线" class="headerlink" title="总线,"></a>总线,</h1><p>  计算机的组成部件间用于传输数据或者指令的物理（软件逻辑）线路，以下列举一些嵌入式中常见的总线和其他总线</p>
<h1 id="MIPI"><a href="#MIPI" class="headerlink" title="MIPI"></a>MIPI</h1><h1 id="HDMI"><a href="#HDMI" class="headerlink" title="HDMI"></a>HDMI</h1><h1 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h1><p>  　　标准的SPI总线是有CS（chip select)&#x2F;SS(slave select), CLOCK, MISO(Master IN Slave out), MOSI 四条线，用于nor flash的扩展的SPI额外多了两条引脚 WP（write protect）,HOLD(用于禁止主机和flash器件的所有通讯)<br>  　　常见的1-wire(只用一条数据线，bitbang,只能单工), 2-wire（可以双工）, 4-wire(使用WP和HOLD脚作为额外的两条数据线) 都是说用来传输数据的线的数量<br>  标准的是2-wire, 1-wire 为了节约引脚，4-wire为了提升速率<br>　　SPI通信的开始总是以CS引脚电平拉低开始，拉高而结束<br>  SPI clock的极性（ploar）和相位(phase) 各有0，1两种排列组合出来共有4种，所以spi有4种工作模式<br>　　 四种模式的差异在于读取数据的时机是在第一个还是第二个跳变沿，是上升<br>沿还是下降沿</p>
<table>
<thead>
<tr>
<th align="left">模式别名</th>
<th align="left">CPOL</th>
<th align="center">CPHA</th>
<th align="left">特性点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">mode 0</td>
<td align="left">0</td>
<td align="center">0</td>
<td align="left">空闲（没传输数据）时，时钟线是处于低电平,从第一个上升沿开始采集数据</td>
</tr>
<tr>
<td align="left">mode 1</td>
<td align="left">0</td>
<td align="center">1</td>
<td align="left">空闲（没传输数据）时，时钟线是处于低电平，从第二个上升沿开始采集数据</td>
</tr>
<tr>
<td align="left">mode 2</td>
<td align="left">1</td>
<td align="center">0</td>
<td align="left">空闲（没传输数据）时，时钟线是处于高电平，钟线是处于低电平,从第一个下降沿开始采集数据</td>
</tr>
<tr>
<td align="left">mode 3</td>
<td align="left">1</td>
<td align="center">1</td>
<td align="left">空闲（没传输数据）时，时钟线是处于高电平 ，从第二个下降沿开始采集数据</td>
</tr>
</tbody></table>
<p>时钟的极性<br>　　CPOL &#x3D; 0：表示空闲时是低电平<br>　　CPOL &#x3D; 1：表示空闲时是高电平<br>由于数据传输往往是从跳变沿开始的，也就表示开始传输数据的时候，是下降沿还是上升沿。<br>时钟的相位<br>　　CPHA &#x3D; 0：表示从第一个跳变沿开始采样<br>　　CPHA &#x3D; 1：表示从第二个跳变沿开始采样<br>　　一个时钟周期会有2个跳变沿。而相位，直接决定SPI总线从那个跳变沿开始采样数据。<br>　　至于跳变沿究竟是上升沿还是下降沿，这取决于 CPOL。记住， CPHA 只决定是哪个跳变沿采样。<br>　　数据发送应该是MSB first<br>ps:<br> 　关于SPI的通讯可以参考一些SPI Nor Flash的器件手册，手册上有清晰易懂的图形，或者参考文末的参考博客链接</p>
<h1 id="I2C-IIC"><a href="#I2C-IIC" class="headerlink" title="I2C (IIC)"></a>I2C (IIC)</h1><p>　　　发音 I two see 或者　I square see 全拼写为　Inter－Integrated Circuit<br>  　　飞利浦公司发明的，只用两条线，一条clock,一条data，支持多主机多从机的模式，需要固定的设备地址，因为只需要用到两条线，所以很在嵌入式设备（板子上)很流行<br>  I2C总线支持的速率有几种</p>
<table>
<thead>
<tr>
<th align="center">I2C Mode</th>
<th align="left">Speed</th>
<th align="left">特性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Standard Mode</td>
<td align="left">100 Kbps</td>
<td align="left">Similar in Implementation, with different timing requirements</td>
</tr>
<tr>
<td align="center">Fast Mode</td>
<td align="left">400 Kbps</td>
<td align="left">Similar in Implementation, with different timing requirements</td>
</tr>
<tr>
<td align="center">Fast Mode Plus</td>
<td align="left">1Mbps</td>
<td align="left">Similar in Implementation, with different timing requirements</td>
</tr>
<tr>
<td align="center">High Speed Mode</td>
<td align="left">3.4Mbps</td>
<td align="left">Reques controller code for high speed transfre</td>
</tr>
<tr>
<td align="center">Ultra-Fast Mode</td>
<td align="left">5 Mbps</td>
<td align="left">Write-only, Omits some standard I2C features</td>
</tr>
</tbody></table>
<p>  I2C的时序图如下<br>  <img src="https://i.loli.net/2021/09/05/K14Ap7SfdmguoBU.png" alt="I2C_timing_diagram.png"><br>  I2C上的数据仅在时钟线为高电平的时候有效(SCLline high, SDA is Stable)，其取值为1&amp;0 &#x3D; 0 ， 1 &amp; 1 &#x3D; 1<br>  I2C上的ACK &#x3D; 逻辑 ‘0’<br>  I2C上的NACK &#x3D; 逻辑’1’<br>  R &#x3D; 逻辑’1’<br>  W &#x3D; 逻辑 ‘0’<br>  发送数据是从MSB..LSB的顺序</p>
<p>ps：<br>  参考资料 来自德州仪器网站的<br>  slides-i2c-protocol.pdf</p>
<h1 id="I3C"><a href="#I3C" class="headerlink" title="I3C"></a>I3C</h1><h1 id="UART"><a href="#UART" class="headerlink" title="UART"></a>UART</h1><h1 id="PCI"><a href="#PCI" class="headerlink" title="PCI"></a>PCI</h1><h1 id="NVME"><a href="#NVME" class="headerlink" title="NVME"></a>NVME</h1><h1 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h1><h1 id="ACPI"><a href="#ACPI" class="headerlink" title="ACPI"></a>ACPI</h1><h1 id="SCSI"><a href="#SCSI" class="headerlink" title="SCSI"></a>SCSI</h1><h1 id="platform-bus"><a href="#platform-bus" class="headerlink" title="platform bus"></a>platform bus</h1><h1 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h1><p>SPI部分内容参考了<br><a href="https://www.cnblogs.com/gmpy/p/12461461.html">https://www.cnblogs.com/gmpy/p/12461461.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>C++ VS c</title>
    <url>/2020/02/24/about-c-cpp/</url>
    <content><![CDATA[<h1 id="C-曾经被叫做C-With-class-C-是兼容C的，并不是100-兼容"><a href="#C-曾经被叫做C-With-class-C-是兼容C的，并不是100-兼容" class="headerlink" title="C++ 曾经被叫做C With class, C++ 是兼容C的，并不是100%兼容"></a>C++ 曾经被叫做C With class, C++ 是兼容C的，并不是100%兼容</h1><p>  C++ 中的C子集是C++的一部分，C语言中允许的东西到C++中可能会不允许  </p>
<ol>
<li>全局变量初始化: C语言中只能使用 constant初始化全局变量 C++可以通过函数初始化<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;inside init func\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_int = <span class="built_in">init</span>(); <span class="comment">// 此语句cpp文件能够编译执行，c文件编译失败</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global_int= %d\n&quot;</span>, global_int);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C-的C子集-是更好的C，将C中的一些不严格的编译检查，变得相对更严格"><a href="#C-的C子集-是更好的C，将C中的一些不严格的编译检查，变得相对更严格" class="headerlink" title="C++的C子集 是更好的C，将C中的一些不严格的编译检查，变得相对更严格"></a>C++的C子集 是更好的C，将C中的一些不严格的编译检查，变得相对更严格</h1></li>
</ol>
<h1 id="C-编译器编译之后函数的-mangling-name-和C编译器编出来的函数名称的-namgling-name-不一样"><a href="#C-编译器编译之后函数的-mangling-name-和C编译器编出来的函数名称的-namgling-name-不一样" class="headerlink" title="C++ 编译器编译之后函数的 mangling name 和C编译器编出来的函数名称的 namgling name 不一样,"></a>C++ 编译器编译之后函数的 mangling name 和C编译器编出来的函数名称的 namgling name 不一样,</h1><p>　　当C++代码调用非标准规定的的C库(比如说FFmpeg是一个纯C的库)的时候，先包含C的头文件然后使用 </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123; c &#125; </span><br></pre></td></tr></table></figure>
<h1 id="C-中的-引用reference-vs-指针pointer"><a href="#C-中的-引用reference-vs-指针pointer" class="headerlink" title="C++ 中的 引用reference vs 指针pointer"></a>C++ 中的 引用reference vs 指针pointer</h1><p>　　指针是某个内存对象的地址，通过指针可以间接地修改内存对象的内容<br>　　引用是种隐式(implicit)的指针, 是某个对象的别名，通过以引用可以直接操作该对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// 此函数通过引用直接修改指针i, 使其自增1，指针自增或者自减的大小是指针指向的内存的基本类型的大小sizeof(int)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>* &amp; i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">func</span>(i);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i); <span class="comment">// 结果应该是4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Funny Linux Commands</title>
    <url>/2020/02/23/about-cmd/</url>
    <content><![CDATA[<h1 id="nproc"><a href="#nproc" class="headerlink" title="nproc"></a>nproc</h1><p>print the number of processing units available</p>
<h1 id="cat-x2F-proc-x2F-cpuinfo"><a href="#cat-x2F-proc-x2F-cpuinfo" class="headerlink" title="cat &#x2F;proc&#x2F;cpuinfo"></a>cat &#x2F;proc&#x2F;cpuinfo</h1><ul>
<li>Physical id and core id are not necessarily consecutive but they are unique. Any cpu with the same core id are threads in the same core. </li>
<li>Any cpu with the same physical id are threads or cores in the same physical socket.</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>About codestyle</title>
    <url>/2020/01/24/about-codestyle/</url>
    <content><![CDATA[<h1 id="什么是-codestyle"><a href="#什么是-codestyle" class="headerlink" title="什么是 codestyle?"></a>什么是 codestyle?</h1><p>　　codesytle 包括变量、函数命名规范，回车换行的使用，以及空格对齐，还是tab对齐，对齐两个空格，还是四个空格.</p>
<h1 id="为什么团队需要统一codestyle"><a href="#为什么团队需要统一codestyle" class="headerlink" title="为什么团队需要统一codestyle?"></a>为什么团队需要统一codestyle?</h1><p>　　自己写代码只给自己看还可以，爱怎么写就怎么写，只要编译通过跑的起来就ok, 但是涉及到多人协作，就要考虑其他<br>人可能要阅读你的代码.当多人协作使用一套代码时，代码风格不统一就像书法作品中一会儿行书，一会草书，一会儿楷书，<br>一会儿小篆一样，造成风格的混乱会降低阅读效率. 代码是写给人看，顺便给计算机执行的. 人都没法看, 没法维护.</p>
<h1 id="为什么会有-codestyle"><a href="#为什么会有-codestyle" class="headerlink" title="为什么会有 codestyle?"></a>为什么会有 codestyle?</h1><p>　　刚开始的编程语言的编译要求是比较宽松的，比如说C&#x2F;c++&#x2F;Java中对于多余的空格(回车换行等留白)，对indent没有<br>特殊的要求，分号分割就认为是一个语句.python 就是对空格、tab留白要求比较严格的语言，不同的缩进可能会导致不同的<br>语义，也可能编译、执行失败, 我认为空格和回车的使用是导致风格之间差异的重要因素.</p>
<h1 id="我自己的感受"><a href="#我自己的感受" class="headerlink" title="我自己的感受"></a>我自己的感受</h1><p>　　在公司求严格的codesytle之后，刚开始还不太习惯，习惯之后回头看自己之前写的代码，忍不住想动手改一下codestyle，不改两下看不下去。。。</p>
<h1 id="有趣的比赛-IOCCC"><a href="#有趣的比赛-IOCCC" class="headerlink" title="有趣的比赛 IOCCC"></a>有趣的比赛 IOCCC</h1><p>　　IOCCC (International Obfuscated C Code Contest) 是国际混淆C代码大赛，看谁的代码写的更令人看不懂，但功能又很<br>有趣或者实用, 比赛的目的是从反面告诉人们要注意code style , 同时参赛者也在展示自己对C语言的理解和其他编程功力 <br><br><a href="https://www.ioccc.org/years.html">历年获奖的作品</a></p>
]]></content>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title>about-design-pattern</title>
    <url>/2021/08/24/about-design-pattern/</url>
    <content><![CDATA[<p>扩展的方法，1继承的方法，2. 组合的方式<br>组合优于继承</p>
<p>封装变化点：<br>将稳定点，与变化点隔离开</p>
]]></content>
  </entry>
  <entry>
    <title>About Editors</title>
    <url>/2020/01/19/about-editors/</url>
    <content><![CDATA[<h1 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h1><p>  stream editor for filtering and transforming text，直译流编辑器它和awk,grep好像被称做linux下文本处理的三剑客.主要来非交互式的处理文本，用于改配置文件等操作</p>
<h1 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h1><p>   vim 有编辑器之神之称<br>   vim 的学习曲线很陡峭，刚开是使用的时候甚至无法输入字符，也找不到怎么退出. 只有alt + F4 关闭终端<br>　　vim 编辑器有不同的模式，插入模式，浏览模式，行编辑模式，命令模式等，需要使用按键组合（ESS）进行模式切换<br>   vim 刚开是不习惯使用ijkl进行上下左右的光标移动操作，逐渐熟悉之后会很习惯,反而不喜欢上下左右的箭头</p>
<h1 id="emacs"><a href="#emacs" class="headerlink" title="emacs"></a>emacs</h1><p>   emacs被称为神之编辑器(伪装成编辑器的操作系统，因为他的shell扩展支持，在emacs的命令行中可以执行很多操作)<br>emacs刚开始学习的时候不至于无法输入字符，但是退出和保存并不是那么显而易见,(渐渐的ctrl + x, ctrl + c就熟练了)</p>
<h1 id="vscode"><a href="#vscode" class="headerlink" title="vscode"></a>vscode</h1><p>  微软公司开发的编辑器，有很多插件，跨平台的普通编辑器</p>
<h1 id="notepad"><a href="#notepad" class="headerlink" title="notepad++"></a>notepad++</h1><p>  好像是一个韩国人开发的软件，目前网站在国内不怎么好打开，体积比较小，用起来功能挺多的，开发工作中比较常用，有查看16进制的插件</p>
<h1 id="sublime"><a href="#sublime" class="headerlink" title="sublime"></a>sublime</h1><p>   不怎么用的感觉，有免费版本可以用</p>
<h1 id="atom"><a href="#atom" class="headerlink" title="atom"></a>atom</h1><p>   Atom是由GitHub开发的自由及开放源代码的文字与代码编辑器，支持macOS、Windows和Linux操作系统,感觉主要是web前端的人在用</p>
<h1 id="Brackets"><a href="#Brackets" class="headerlink" title="Brackets"></a>Brackets</h1><p>   同上，感觉也是web前端用的人比较多些，好像是由adobe公司开发的</p>
]]></content>
      <tags>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title>About Emacs</title>
    <url>/2020/01/19/about-emacs/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title>about embed software</title>
    <url>/2021/09/04/about-embed-software/</url>
    <content><![CDATA[<h1 id="busybox"><a href="#busybox" class="headerlink" title="busybox"></a>busybox</h1><p>  Swiss Knife for embed, include a lot of linux cmd (include, vi ,sed, awk, etc)</p>
<h1 id="mbedtls"><a href="#mbedtls" class="headerlink" title="mbedtls"></a>mbedtls</h1><p>   The Mbed TLS library is designed to integrate with existing (embedded) applications and to provide the building blocks for secure communication, cryptography and key management<br>   learn it @ <a href="https://tls.mbed.org/kb/how-to/mbedtls-tutorial">https://tls.mbed.org/kb/how-to/mbedtls-tutorial</a><br>   主要用于arm, is  for substituting openssl </p>
<h1 id="dropbear"><a href="#dropbear" class="headerlink" title="dropbear"></a>dropbear</h1><p>   is a ssh server for embed use</p>
<h1 id="musl-libc"><a href="#musl-libc" class="headerlink" title="musl libc"></a>musl libc</h1><p>   light weight libc for embed environment</p>
<h1 id="uCore-libc"><a href="#uCore-libc" class="headerlink" title="uCore libc"></a>uCore libc</h1><p>   light weight libc for embed environment</p>
<h1 id="uClinux"><a href="#uClinux" class="headerlink" title="uClinux"></a>uClinux</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
  </entry>
  <entry>
    <title>about-encoding</title>
    <url>/2020/02/23/about-encoding/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>加密算法</title>
    <url>/2022/03/23/about-encryption/</url>
    <content><![CDATA[<ul>
<li>Sm3 国密加密<br>华为的openEuler20 安装的时候 用户密码的加密存储支持  此算法</li>
<li>aes-ecb<br>最简单的加密模式即为电子密码本（Electronic codebook，ECB）模式,<br> 需要加密的消息按照块密码的块大小被分为数个块，并对每个块进行独立加密</li>
<li>aes-cbc<br>1976年，IBM发明了密码分组链接（CBC，Cipher-block chaining）模式,<br>在CBC模式中，每个明文块先与前一个密文块进行异或后，再进行加密。<br>在这种方法中，每个密文块都依赖于它前面的所有明文块。<br>同时，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量.</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>About Endianness</title>
    <url>/2020/02/20/about-endian/</url>
    <content><![CDATA[<h1 id="大小端问题-big-endian-little-endian"><a href="#大小端问题-big-endian-little-endian" class="headerlink" title="大小端问题(big endian little endian)"></a>大小端问题(big endian little endian)</h1><p>　　In computing, endianness refers to the order of bytes (or sometimes bits) within a binary representation of a number<br>　　In its most common usage, endianness indicates the ordering of bytes within a multi-byte number. A big-endian ordering places the most significant byte first and the least significant byte last,<br>　　while a little-endian ordering does the opposite  </p>
<p>　　Historically, various methods of endianness have been used in computing, including exotic forms such as middle-endianness. Today, however, big-endianness is the dominant ordering in networking protocols (IP, TCP, UDP). Conversely, little-endianness is the dominant ordering for processor architectures (x86, most ARM implementations) and their associated memory. File formats can use either ordering; some formats use a mixture of both.</p>
<h1 id="大小端的定义"><a href="#大小端的定义" class="headerlink" title="大小端的定义"></a>大小端的定义</h1><p><strong>Big Endian Byte Order</strong>:<br>　　<em>The most significant byte (the “big end”) of the data is placed at the byte with the lowest address. The rest of the data is placed in order in the next three bytes in memory.</em></p>
<p><strong>Little Endian Byte Order</strong>:  (LL)<br>　　<em>The least significant byte (the “little end”) of the data is placed at the byte with the lowest address. The rest of the data is placed in order in the next three bytes in memory.</em></p>
<h1 id="linux-中转换大小端的函数"><a href="#linux-中转换大小端的函数" class="headerlink" title="linux 中转换大小端的函数"></a>linux 中转换大小端的函数</h1>  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ man endian </span><br></pre></td></tr></table></figure>
<p>  通过以上命令可以获取到转换大小端的函数  </p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// h short for host</span></span><br><span class="line"><span class="comment">// b short for big endian</span></span><br><span class="line"><span class="comment">// l short for little endian</span></span><br><span class="line"><span class="comment">// 32 means 32 bits integer</span></span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">htobe32</span><span class="params">(<span class="type">uint32_t</span> host_32bits)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">htole32</span><span class="params">(<span class="type">uint32_t</span> host_32bits)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">be32toh</span><span class="params">(<span class="type">uint32_t</span> big_endian_32bits)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">le32toh</span><span class="params">(<span class="type">uint32_t</span> little_endian_32bits)</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="大小端的影响范围"><a href="#大小端的影响范围" class="headerlink" title="大小端的影响范围"></a>大小端的影响范围</h1><ol>
<li>文件系统的创建</li>
<li>网络传输协议的字节序(一般是大端，也有小端Server_Message_Block)<h1 id="判断大小端的C代码"><a href="#判断大小端的C代码" class="headerlink" title="判断大小端的C代码"></a>判断大小端的C代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// from linux-5.4.3\arch\arm\kernel\setup.c 中161行的一个宏，</span></span><br><span class="line"><span class="comment">// 内核中的写法稍有不同稍加修改可以正常编译</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">checkCPUendian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">static</span> <span class="keyword">union</span> &#123; <span class="type">char</span> c[<span class="number">4</span>]; <span class="type">unsigned</span> <span class="type">long</span> l; &#125; endian_test = &#123; &#123; <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;b&#x27;</span> &#125; &#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENDIANNESS ((char)endian_test.l)</span></span><br><span class="line"><span class="comment">//if ENDIANNESS==&#x27;l&#x27;  the CPU is little-endian if ENDIANESS==&#x27;b&#x27; the CPU is big-endian</span></span><br><span class="line">  <span class="keyword">return</span> ENDIANNESS == <span class="string">&#x27;l&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title>about-ethernet</title>
    <url>/2021/08/26/about-ethernet/</url>
    <content><![CDATA[<p>以太网帧的尺寸<br><a href="https://www.zhihu.com/question/58979135">https://www.zhihu.com/question/58979135</a></p>
]]></content>
  </entry>
  <entry>
    <title>About FFmpeg</title>
    <url>/2020/02/14/about-ffmpeg/</url>
    <content><![CDATA[<h1 id="FFmpeg-是开源音视频解码库"><a href="#FFmpeg-是开源音视频解码库" class="headerlink" title="FFmpeg 是开源音视频解码库"></a>FFmpeg 是开源音视频解码库</h1><p>　　很多音视频软件都使用到了ffmpeg的解码库</p>
<h1 id="把图片从raw-data-转换成jpg的命令"><a href="#把图片从raw-data-转换成jpg的命令" class="headerlink" title="把图片从raw data 转换成jpg的命令"></a>把图片从raw data 转换成jpg的命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg -i inputrawdata -s 512x800  -f rgb565   -f image2 -o out.jpeg</span><br></pre></td></tr></table></figure>
<h1 id="音视频合并-从网站上下载的视频可能音频和视频分开的为了方便观看需要合并"><a href="#音视频合并-从网站上下载的视频可能音频和视频分开的为了方便观看需要合并" class="headerlink" title="音视频合并 从网站上下载的视频可能音频和视频分开的为了方便观看需要合并"></a>音视频合并 从网站上下载的视频可能音频和视频分开的为了方便观看需要合并</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ffmpeg -i inputaudio -i inputvideo  output.mp4</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>about filesystems</title>
    <url>/2022/03/23/about-filesystems/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 linux 支持的文件系统</span></span><br><span class="line"><span class="built_in">cat</span> /proc/filesystems</span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/1523623/202203/1523623-20220320235459194-1258184622.png"></p>
<ul>
<li>procfs  常见的 内存文件系统<br>The proc filesystem doesn’t support capabilities, ACL, or even changing basic permissions with chmod. Unix permissions determine whether the calling process gets access. Thus only root can write that file. With user namespaces, that’s the global root (the one in the original namespace); root in a container doesn’t get to change sysctl settings.</li>
<li>sysfs<br>常见的内存文件系统</li>
<li>tmpfs<br>支持 xattr  常见的内存文件系统</li>
<li>jffs2<br>支持 xattr 嵌入式常用的带有日志的</li>
<li>squashfs<br> 支持xattr 高压缩只读文件系统</li>
<li>iso9660<br> 光盘iso格式的文件系统</li>
<li>ext4<br>支持 xattr Linux下常见的文件系统</li>
<li>fat32<br>或者vfat ，U盘，sdcard常见文件系统</li>
<li>NTFS<br> Windows NTFS（英語：New Technology File System），是Microsoft公司开发的专用文件系统，从Windows NT 3.1开始成为Windows NT家族的默认文件系统。</li>
<li>NFS<br>网络文件系统 (Network File System)<br>【参考】<br><a href="https://tldp.org/LDP/Linux-Filesystem-Hierarchy/html/proc.html">https://tldp.org/LDP/Linux-Filesystem-Hierarchy/html/proc.html</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>About GCC</title>
    <url>/2020/01/20/about-gcc/</url>
    <content><![CDATA[<h2 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h2><p>　　gcc 是 GNU Compiler Collection 的缩写，不仅支持 C&#x2F;C++的编译，还支持Java等</p>
<h2 id="gcc-基本操作"><a href="#gcc-基本操作" class="headerlink" title="gcc 基本操作"></a>gcc 基本操作</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc hello.c -o hello </span><br></pre></td></tr></table></figure>
<p>　　会编译输出 hello 可执行文件，如果不使用-o选项指定输出的文件名怎会生成 a.out文件</p>
<h2 id="神奇的a-out"><a href="#神奇的a-out" class="headerlink" title="神奇的a.out"></a>神奇的a.out</h2><p>　　是汇编(assemble)输出(output)的意思在freebsd 中 man a.out 可以看到相关信息</p>
<h2 id="gcc的扩展支持语法"><a href="#gcc的扩展支持语法" class="headerlink" title="gcc的扩展支持语法"></a>gcc的扩展支持语法</h2><ol>
<li>函数内部定义函数   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">foo</span> (<span class="type">double</span> a, <span class="type">double</span> b)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">square</span> <span class="params">(<span class="type">double</span> z)</span> </span>&#123; <span class="keyword">return</span> z * z; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">square</span> (a) + <span class="built_in">square</span> (b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title>About Git</title>
    <url>/2020/01/18/about-git/</url>
    <content><![CDATA[<h1 id="git-the-stupid-content-tracker"><a href="#git-the-stupid-content-tracker" class="headerlink" title="git - the stupid content tracker"></a>git - the stupid content tracker</h1><p>  Git is a fast, scalable, distributed revision control system<br>with an unusually rich command set that provides<br>both high-level operations and full access to internals.</p>
<h2 id="git的基本配置"><a href="#git的基本配置" class="headerlink" title="git的基本配置"></a>git的基本配置</h2><ul>
<li><p>设置用户名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置邮箱</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global user.email <span class="string">&quot;your_email@whatever.com&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置换行符</p>
<ul>
<li>linux&#x2F;unix&#x2F;Mac 用户</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global core.autocrlf input; git config --global core.safecrlf <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<pre><code>* windows 用户
</code></pre>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config --global core.autocrlf <span class="literal">true</span>; git config --global core.safecrlf <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>配置文件 ~&#x2F;.gitconfig</p>
<p>  <a href="https://github.com/linuxmint17/confs/blob/master/gitconfig">github&#x2F;linuxmint17&#x2F;confs&#x2F;blob&#x2F;master&#x2F;gitconfig</a></p>
</li>
</ul>
<h2 id="git-的基础操作"><a href="#git-的基础操作" class="headerlink" title="git 的基础操作"></a>git 的基础操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ mkdir code</span><br></pre></td></tr></table></figure>
<p>初始化git仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git init -c code</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> code</span><br></pre></td></tr></table></figure>
<p>使用最喜欢(emacs&#x2F;vim&#x2F;nano&#x2F;notepad++&#x2F;sublime&#x2F;vscode)的编辑器编辑文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ emacs hello.c  </span><br></pre></td></tr></table></figure>
<p>添加文件到暂存区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add hello.c</span><br></pre></td></tr></table></figure>
<p>检查git仓库状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">$ git status . -u no <span class="comment"># don&#x27;t display the untracked files  . mean current git repo</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -s <span class="string">&quot; init commit of repo&quot;</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>
<p>revert a commit</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git revert commit-id</span><br></pre></td></tr></table></figure>
<p>start a branch</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch my-branch-name</span><br><span class="line"># how to name a branch ,name it after a real co-workers&#x27;name ,if it&#x27;s only for him/her, then you can commit on that branch won&#x27;t mess things up</span><br><span class="line"># in the commit log you can describe what this commit about  , it&#x27;s usually for debugsome functions or purly for uploading code, or name it</span><br><span class="line"># after a feature function you are developing, is great</span><br></pre></td></tr></table></figure>
<h2 id="how-to-use-a-git-patch"><a href="#how-to-use-a-git-patch" class="headerlink" title="how to use a git patch"></a>how to use a git patch</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># this is git foramt patch version contains commit-msg</span></span><br><span class="line">git format-patch commit-id</span><br><span class="line">git apply/am xxx-001-patch</span><br><span class="line"><span class="comment"># this is old fashion diff vpatch ersion</span></span><br><span class="line">git diff &gt; xxx.diff</span><br><span class="line">git am/apply xxx.idff</span><br></pre></td></tr></table></figure>
<h2 id="git-小技巧"><a href="#git-小技巧" class="headerlink" title="git 小技巧"></a>git 小技巧</h2><h3 id="暂存"><a href="#暂存" class="headerlink" title="暂存"></a>暂存</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash</span><br></pre></td></tr></table></figure>
<h3 id="挑选"><a href="#挑选" class="headerlink" title="挑选"></a>挑选</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git  cherry-pick commit-id</span><br></pre></td></tr></table></figure>
<h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rebase -i commit-id</span><br></pre></td></tr></table></figure>
<h3 id="查看文件变更"><a href="#查看文件变更" class="headerlink" title="查看文件变更"></a>查看文件变更</h3><p>　　查看 hello.c 文件中的10到20行的修改记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git blame -L 10,20 hello.c</span><br></pre></td></tr></table></figure>
<h3 id="从历史版本中取出某个文件"><a href="#从历史版本中取出某个文件" class="headerlink" title="从历史版本中取出某个文件"></a>从历史版本中取出某个文件</h3><p>　　从历史版本(commit-id)中取出hello.c</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  git checkout  commit-id  hello.c</span><br></pre></td></tr></table></figure>
<h3 id="commit-it-when-debug-or-develop-has-been-done-some-of-it-at-the-last-time-you-can-rebase-it-or-git-reset-–soft-it"><a href="#commit-it-when-debug-or-develop-has-been-done-some-of-it-at-the-last-time-you-can-rebase-it-or-git-reset-–soft-it" class="headerlink" title="commit it when debug or develop has been done some of it , at the last time you can rebase it or git reset –soft it"></a>commit it when debug or develop has been done some of it , at the last time you can rebase it or git reset –soft it</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># use the last commit-id</span></span><br><span class="line">git commit --amend  </span><br><span class="line"><span class="comment"># </span></span><br><span class="line">git reset --soft</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">git reset --mixed</span><br></pre></td></tr></table></figure>
<h3 id="我在哪个分支，merge是否成功，rebase-是否成功，cherry-pick是否成功？"><a href="#我在哪个分支，merge是否成功，rebase-是否成功，cherry-pick是否成功？" class="headerlink" title="我在哪个分支，merge是否成功，rebase 是否成功，cherry-pick是否成功？"></a>我在哪个分支，merge是否成功，rebase 是否成功，cherry-pick是否成功？</h3><p>　　配置shell的命令提示符可以帮你解决这个问题</p>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. git <span class="built_in">clone</span> git://git.kernel.org/pub/scm/git/git.git</span><br><span class="line">2. <span class="built_in">cp</span> git/contrib/completion/git-completion.bash ~/.git-completion.bash</span><br><span class="line">3. <span class="built_in">cp</span> git/contrib/completion/git-prompt.sh  ~/.git-prompt.sh</span><br><span class="line">4. vi ~/.bashrc 插入</span><br><span class="line"><span class="built_in">export</span> GIT_PS1_SHOWDIRTYSTATE=1</span><br><span class="line"><span class="built_in">export</span> GIT_PS1_SHOWSTASHSTATE=1</span><br><span class="line"><span class="built_in">export</span> GIT_PS1_SHOWUNTRACKEDFILES=1</span><br><span class="line"><span class="built_in">export</span> GIT_PS1_SHOWUPSTREAM=”verbose git svn”</span><br><span class="line"><span class="built_in">export</span> PS1=<span class="string">&#x27;\[\033[0;32m\]\D&#123;%Y/%m/%d&#125; \t\[\033[0m\]\[\033[0;35m\]\u@\h\[\033[0m\]\[\033[0;33m\]\w\[\033[36m\]$(__git_ps1 &quot; (%s)&quot;)\[\033[0m\]\n\$&#x27;</span></span><br><span class="line">5. <span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h2 id="some-other-concepts"><a href="#some-other-concepts" class="headerlink" title="some other concepts"></a>some other concepts</h2><ul>
<li><p>base, detached head, </p>
<h2 id="git-底层命令"><a href="#git-底层命令" class="headerlink" title="git 底层命令"></a>git 底层命令</h2><p>　　挖坑 想起来再填</p>
<h2 id="git-的detached-head"><a href="#git-的detached-head" class="headerlink" title="git 的detached head"></a>git 的detached head</h2><p>  很有趣</p>
<h2 id="学习git的资源"><a href="#学习git的资源" class="headerlink" title="学习git的资源"></a>学习git的资源</h2></li>
<li><p>git的官方网站 <a href="https://git-scm.com/">git-scm.com</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Tools git</tag>
      </tags>
  </entry>
  <entry>
    <title>About inline function</title>
    <url>/2020/01/20/about-inline/</url>
    <content><![CDATA[<p>inline 是C99&#x2F;C++的关键字之一，目的是取代函数式宏，函数式宏没有类型</p>
<h2 id="内联函数-vs-函数式宏（待考证，可能有谬误）"><a href="#内联函数-vs-函数式宏（待考证，可能有谬误）" class="headerlink" title="内联函数 vs 函数式宏（待考证，可能有谬误）"></a>内联函数 vs 函数式宏（待考证，可能有谬误）</h2><ul>
<li>编译中的差别：<br><ul>
<li>内联函数 在编译时在调用函数中<br>内敛只是是一种建议(像regester 一样),不一定被编译器采纳(The inline specification is only a request to the compiler. The compiler may<br>choose to ignore this request – – C++ primer)，如果内敛函数很复杂(循环嵌套比较多)，或者包含静态变量等情况就无法内敛就无法被编译器当做是内联函数</li>
<li>函数式宏 在预处理阶段被文本替换，在预处理阶段必然被替换</li>
</ul>
</li>
<li>二进制的区别：<br><ul>
<li>函数式宏 如果被使用多次 代码区增大</li>
<li>内联函数 如果被使用多次 代码区域没有显著增大</li>
</ul>
</li>
<li>运行时的差别：<br><ul>
<li>函数式宏，不是函数，在运行时没有体现</li>
<li>内联函数，几乎没有函数参数传递的开销<h2 id="不同编译器对-inline-的支持"><a href="#不同编译器对-inline-的支持" class="headerlink" title="不同编译器对 inline 的支持"></a>不同编译器对 inline 的支持</h2></li>
</ul>
</li>
<li>clang<br>挖坑</li>
<li>gcc<br>挖坑</li>
</ul>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>about-interrupt</title>
    <url>/2020/05/24/about-interrupt/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>About Java</title>
    <url>/2020/02/19/about-java/</url>
    <content><![CDATA[<h1 id="Java是啥？"><a href="#Java是啥？" class="headerlink" title="Java是啥？"></a>Java是啥？</h1><p> 　　Java是面向对象编程语言，最早是Sun公司的后来被Oracle收购了，已经有20多年的历史了，是为了针对c++的缺点</p>
<h1 id="Java-编程环境配置"><a href="#Java-编程环境配置" class="headerlink" title="Java 编程环境配置"></a>Java 编程环境配置</h1><p> 　　java运行依赖于java虚拟机,所以要安装JDK,因为java规范和jvm 规范是公开的，所以jdk有开源实现版本openjdk，JDK 和oracle JDK<br> 　　具体步骤可以参考<a href="https://docs.oracle.com/cd/E19182-01/820-7851/inst_cli_jdk_javahome_t/">此链接</a></p>
<ol>
<li>安装JDK<br>　　谷歌或者百度，搜索 oracle jdk,下载安装</li>
<li>配置 <strong>JAVA_HOME</strong>, <strong>CLASSPATH</strong> 和 <strong>PATH</strong> 等环境变量</li>
</ol>
<p>　　</p>
<p>　　<strong>PATH</strong> 环境变量中是平台可执行文件的所在的路径的集合　　</p>
<p>　　<strong>JAVA_HOME</strong> 指向JDK software 安装的地方,比如说, D:\Program Files\Java\jdk1.8.0_181　　</p>
<p>　　<strong>CLASSPATH</strong> variable is one way to tell applications, including the JDK tools, where to look for user classes. (Classes that are part of the JRE, JDK platform, and extensions should be defined through other means, such as the bootstrap class path or the extensions directory.)</p>
<p>　　The preferred way to specify the class path is by using the -cp command line switch. This allows the CLASSPATH to be set individually for each application without affecting other applications. Setting the CLASSPATH can be tricky and should be performed with care.</p>
<p>　　The default value of the class path is “.”, meaning that only the current directory is searched. Specifying either the CLASSPATH variable or the -cp command line switch overrides this value.</p>
<ol start="3">
<li>配置之后验证</li>
</ol>
<p>　　</p>
<p>　　在新打开的命令行中输入java -version 查看是否有输出版本号，如果有则成功</p>
<h1 id="Java-强迫面向对象编程"><a href="#Java-强迫面向对象编程" class="headerlink" title="Java 强迫面向对象编程"></a>Java 强迫面向对象编程</h1><p> 　　即使想写个简单Hello world程序，也很麻烦。必须创建一个Java类，而且类名和文件名还必须一样  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BitOpt.java</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BitOpt</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    System.out.println(a&gt;&gt;&gt;<span class="number">30</span>);</span><br><span class="line">    System.out.println(a&gt;&gt;<span class="number">30</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="Java-之JNI-Java-Native-Interface"><a href="#Java-之JNI-Java-Native-Interface" class="headerlink" title="Java 之JNI(Java Native Interface)"></a>Java 之JNI(Java Native Interface)</h1><p>  java 为了吸收和利用现有的C和C++代码提供了JNI接口，用于使用C和C++代码提供了JNI接口，用于使用C和C++<br>  Android应用apk中的.so文件是动态库允许厂商将自己的私有算法封装进入so库，提供一定程度的密码保护.<br>  在一些比较耗时的算法场景，使用jni可以加快程序运行速度</p>
]]></content>
  </entry>
  <entry>
    <title>About Lint</title>
    <url>/2020/03/07/about-lint/</url>
    <content><![CDATA[<h1 id="lint-或者-linter是-一种静态程序分析工具"><a href="#lint-或者-linter是-一种静态程序分析工具" class="headerlink" title="lint 或者 linter是 一种静态程序分析工具"></a>lint 或者 linter是 一种静态程序分析工具</h1><p>  这里的静态是指在不运行程序的情况下检查代码潜在的问题<br>  最早在Unix平台上开发用于检查C语言程序的<br>  后来被其他的语言借鉴形成了各种各样的lint工具，以提升代码的健壮性</p>
<h1 id="splint-是现在的-linux上的lint工具-安装方法-如下"><a href="#splint-是现在的-linux上的lint工具-安装方法-如下" class="headerlink" title="splint 是现在的 linux上的lint工具 安装方法 如下"></a>splint 是现在的 linux上的lint工具 安装方法 如下</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># apt-get install -y splint</span></span><br></pre></td></tr></table></figure>
<h1 id="splint-从哪里知道的？"><a href="#splint-从哪里知道的？" class="headerlink" title="splint 从哪里知道的？"></a>splint 从哪里知道的？</h1><p>  来自《C专家编程》中的某个章节</p>
<h1 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func.c</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">int</span> <span class="comment">/*@unused@*/</span>a,<span class="type">char</span> **b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  splint func.c </span><br></pre></td></tr></table></figure>
<p>会输出警告信息</p>
<h1 id="详细用法可以参考"><a href="#详细用法可以参考" class="headerlink" title="详细用法可以参考"></a>详细用法可以参考</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man splint</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>About Linux</title>
    <url>/2020/01/20/about-linux/</url>
    <content><![CDATA[<h2 id="Linux-的作用范围"><a href="#Linux-的作用范围" class="headerlink" title="Linux 的作用范围"></a>Linux 的作用范围</h2><p>　　Linux 本来仅仅是指一种<strong>类Unix系统</strong>(和unix比较像的操作系统称为<strong>类Unix系统</strong>)的kernel, 不包括 shell等其它实用工具.</br><br>随着linux的日益壮大或者人们的口口相传，原本应该是GNU&#x2F;Linux 指代整个操作系统，后来渐渐Linux 也指代整个操作系统. </br><br>但是在具体的上下文环境中还是可以分清楚是指代内核还是整个操作系统</p>
<h2 id="Linux-的常见发行版本"><a href="#Linux-的常见发行版本" class="headerlink" title="Linux 的常见发行版本"></a>Linux 的常见发行版本</h2><p>　　首先解释什么是发行版本：发行版本是开源社区或者公司，甚至是个人把Linuxkernel拿过来，整合其它的使用工具，以及软件管理工具装配的一个便于终端用户使用的操作系统<br>根据软件包管理工具的不同大概分为两个系列 :Debian 系列(使用 dpkg 作为底层工具)和 Redhat 系列(使用 rpm 作为底层工具),还有一些特立独行的发行版本使用的是其他的软件包管理工具(比如说 arch,和 gentoo)</p>
<ul>
<li><strong>dpkg 系</strong><ul>
<li><strong>Debian</strong></li>
<li><strong>Ubuntu</strong></li>
<li><strong>Linuxmint</strong></li>
<li><strong>Deepin</strong></li>
</ul>
</li>
<li><strong>rpm 系</strong><ul>
<li><strong>Redhat</strong></li>
<li><strong>CentOS</strong></li>
<li><strong>Fedora</strong></li>
<li><strong>SUSE</strong></li>
<li><strong>OpenSUSE</strong></li>
</ul>
</li>
<li><strong>pacman 系</strong><ul>
<li><strong>Arch Linux</strong></li>
<li><strong>Manjaro Linux</strong></li>
</ul>
</li>
<li><strong>其他系列</strong><ul>
<li>** gentoo Linux 主张一切从源码安装，好像没有包管理工具</li>
<li>** LFS(Linux from Scratch) 算不上一个系统，从源码装一个可以运行的操作系统<h2 id="为什么要了解Linux"><a href="#为什么要了解Linux" class="headerlink" title="为什么要了解Linux"></a>为什么要了解Linux</h2></li>
</ul>
</li>
<li>实用</li>
<li>免费<h2 id="linux各式各样，为了加强linux的兼容性Linux基金会成立的一个-项目-LSB-规范linux发行版的一些行为"><a href="#linux各式各样，为了加强linux的兼容性Linux基金会成立的一个-项目-LSB-规范linux发行版的一些行为" class="headerlink" title="linux各式各样，为了加强linux的兼容性Linux基金会成立的一个 项目 LSB 规范linux发行版的一些行为"></a>linux各式各样，为了加强linux的兼容性Linux基金会成立的一个 项目 LSB 规范linux发行版的一些行为</h2><a href="https://wiki.linuxfoundation.org/lsb/start">Linux Standard Base (LSB)</a>规定各个目录的作用等</li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>About Makefile</title>
    <url>/2020/01/24/about-makefile/</url>
    <content><![CDATA[<h1 id="make-是用来组织大型工程必不可少的工具"><a href="#make-是用来组织大型工程必不可少的工具" class="headerlink" title="make 是用来组织大型工程必不可少的工具"></a>make 是用来组织大型工程必不可少的工具</h1><p>　　make 有各种变体: Qt的qmake, 跨平台的 cmake, 微软的 nmake</p>
<h1 id="make-menuconfig"><a href="#make-menuconfig" class="headerlink" title="make menuconfig"></a>make menuconfig</h1><p>　　好像最早是在linux kernel 中使用到的, 在构建kernel 之前使用这个命令会<br>  根据kernel目录下的Makefile和其他的文件以及kconfig语法生成命令行的gui菜单可以勾选，依赖 ncurses</p>
<h1 id="make-n"><a href="#make-n" class="headerlink" title="make -n"></a>make -n</h1><p>　　make 调试使用的命令，空跑一次，不执行实际操作，把要执行的动作打印出来</p>
<h1 id="make-f-filename"><a href="#make-f-filename" class="headerlink" title="make -f filename"></a>make -f filename</h1><p>　　指定makefile 文件，不默认寻找 Makefile,makefile</p>
<h1 id="make"><a href="#make" class="headerlink" title="make"></a>make</h1><p>　　假设当前目录下有 hello.c 执行make hello 会尝试编译 hello.c 到hello</p>
<h1 id="make-C-dir-name"><a href="#make-C-dir-name" class="headerlink" title="make -C dir_name"></a>make -C dir_name</h1><p>　　执行make 命令之前 进入到 dir_name 中, 常常在项目中递归的使用</p>
<h1 id="make-k"><a href="#make-k" class="headerlink" title="make -k"></a>make -k</h1>]]></content>
      <tags>
        <tag>Tool</tag>
      </tags>
  </entry>
  <entry>
    <title>About memory</title>
    <url>/2020/02/28/about-memory/</url>
    <content><![CDATA[<h1 id="此处讨论的是物理内存，说的是内存的物理特性，不涉及虚拟内存，内存映射等话题"><a href="#此处讨论的是物理内存，说的是内存的物理特性，不涉及虚拟内存，内存映射等话题" class="headerlink" title="此处讨论的是物理内存，说的是内存的物理特性，不涉及虚拟内存，内存映射等话题"></a>此处讨论的是物理内存，说的是内存的物理特性，不涉及虚拟内存，内存映射等话题</h1><h2 id="内存-RAM-分为-静态内存-SRAM-和动态内存-DRAM"><a href="#内存-RAM-分为-静态内存-SRAM-和动态内存-DRAM" class="headerlink" title="内存(RAM)分为 静态内存(SRAM)和动态内存(DRAM)"></a>内存(RAM)分为 静态内存(SRAM)和动态内存(DRAM)</h2><pre><code>静态随机存取存储器是随机存取存储器的一种。所谓的“静态”，是指这种存储器只要保持通电，里面储存的数据就可以恒常保持。相对之下，动态随机存取存储器里面所储存的数据就需要周期性地更新。然而，当电力供应停止时，SRAM储存的数据还是会消失
摘自[维基百科](https://zh.wikipedia.org/zh-cn/E9%9D%99%E6%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8)
</code></pre>
<h2 id="特性对比表格："><a href="#特性对比表格：" class="headerlink" title="特性对比表格："></a>特性对比表格：</h2><table>
<thead>
<tr>
<th align="center">内存类型</th>
<th align="center">SRAM</th>
<th align="center">DRAM</th>
</tr>
</thead>
<tbody><tr>
<td align="center">可用阶段</td>
<td align="center">系统启动过程的任意时刻均可用</td>
<td align="center">需要在初始化频率等之后</td>
</tr>
<tr>
<td align="center">生产成本</td>
<td align="center">高</td>
<td align="center">低</td>
</tr>
<tr>
<td align="center">常见使用场景</td>
<td align="center">寄存器，cache</td>
<td align="center">运行内存</td>
</tr>
<tr>
<td align="center">组成物理器件</td>
<td align="center">略</td>
<td align="center">略</td>
</tr>
</tbody></table>
]]></content>
  </entry>
  <entry>
    <title>mysql</title>
    <url>/2020/02/14/about-mysql/</url>
    <content><![CDATA[<h1 id="mysql-是很流行的一款开源数据库软件"><a href="#mysql-是很流行的一款开源数据库软件" class="headerlink" title="mysql 是很流行的一款开源数据库软件"></a>mysql 是很流行的一款开源数据库软件</h1><p>　　mysql是跨平台的关系型数据库，安装可以参考<a href="https://dev.mysql.com/doc/mysql-sles-repo-quick-guide/en/">mysql安装官网指导</a> <br><br>mysql好像是从5.7版本之后，安装完会有一个随机的root密码使用grep password &#x2F;var&#x2F;log&#x2F;mysqld.log 查找密码，否则无法登陆<br>安装完成之后要用mysql_secure_instation 设置一下安全属性</p>
<h1 id="mysql-基本指令"><a href="#mysql-基本指令" class="headerlink" title="mysql 基本指令"></a>mysql 基本指令</h1><ul>
<li>CREATE DATABASE ssusers; 创建数据库</li>
<li>DROP DATABASE ssusers; 删除数据库</li>
<li>SHOW DATABASES; 显示数据库</li>
<li>CREATE USER ‘ssmanger‘@’localhost’ IDENTIFIED BY ‘123456’; 创建用户 ssmanger 本机可以访问 mysql</li>
<li>GRANT ALL privileges  ON  ssusers.* TO ssmanger@’localhost’; 将数据库所有权限给用户 ssmanager</li>
<li>SET PASSWORD FOR ‘username‘@’host’ &#x3D; PASSWORD(‘newpassword’); 更新mysql用户密码</li>
<li>CREATE USER ‘wordpressadmin‘@’%’ IDENTIFIED BY ‘123456’; 创建用户 wordpressadmin在所有ip可以访问mysql<h1 id="mysql-多表查询"><a href="#mysql-多表查询" class="headerlink" title="mysql 多表查询"></a>mysql 多表查询</h1></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>namespace</title>
    <url>/2020/05/23/about-namespace/</url>
    <content><![CDATA[<h1 id="namespace-命名空间-是C-的一个关键字"><a href="#namespace-命名空间-是C-的一个关键字" class="headerlink" title="namespace (命名空间) 是C++的一个关键字"></a>namespace (命名空间) 是C++的一个关键字</h1><p>　　不同的命名空间中相同的标识符在编译的时候不会产生错误<br>　　在不同的命名空间中可以使用相同名字的变量或者函数名称</p>
<h1 id="C-语言的标识符-也有命名空间-（内容来自-C语言规范草案-6-2-3-节"><a href="#C-语言的标识符-也有命名空间-（内容来自-C语言规范草案-6-2-3-节" class="headerlink" title="C 语言的标识符 也有命名空间 （内容来自 C语言规范草案 6.2.3 节)"></a>C 语言的标识符 也有命名空间 （内容来自 C语言规范草案 6.2.3 节)</h1><ul>
<li>label names<br>标签名 包括 goto 语句 中用到的标签和  switch case中的 标签</li>
<li>the tags name of structures, unions and enumurations<br>结构、联合、枚举的tag名</li>
<li>the members of structures or unions; each structure or union has a seperate name space for its number;<br>结构体、联合的成员名</li>
<li>all other identifiers,called ordinary identifiers (declared in ordinary declarators or as<br>enumeration constants)<br>其他普通的变量，或者枚举常量<h1 id="C-中使用namesapce-关键字可以构造一个命名空间"><a href="#C-中使用namesapce-关键字可以构造一个命名空间" class="headerlink" title="C++中使用namesapce 关键字可以构造一个命名空间"></a>C++中使用namesapce 关键字可以构造一个命名空间</h1> C&#x2F;C++ 中的 每一对花括号 是一个 命名空间</li>
</ul>
<p>#变量的声明(declaration),定义(definition),初始化(initalization)<br>　　C 语言中变量的带初始化的声明就是定义<br>不带有初始化的全局对象构成了一个 试探性定义<br>这个Tentative definitions 特性仅仅C语言只有，C++是不支持的</p>
<p>　　在两个C文件中同时声明两个一模一样的未初始化的全局变量的时候，<br>C语言能够编译通过的C++不支持这样的</p>
<h1 id="C-类copy-constructor-的执行时机就很有趣"><a href="#C-类copy-constructor-的执行时机就很有趣" class="headerlink" title="C++ 类copy constructor 的执行时机就很有趣"></a>C++ 类copy constructor 的执行时机就很有趣</h1><p>C++ 对于 将一个对象的值 赋给 另一个对象的 场景进行了细分<br>一类就是 赋值；赋值的时候使用的是 &#x3D; 的重载函数<br>另一类就是 初始化；<br>初始化可能发生的三个场景 ：</p>
<ol>
<li>在声明变量的同时用另一个对象初始化</li>
<li>对象的拷贝被当做函数参数传递</li>
<li>临时对象产生的时候，例如返回值是一个对象的时候</li>
</ol>
<h1 id="C语言标准规定-不应该-使用-对全局变量使用-register-修饰"><a href="#C语言标准规定-不应该-使用-对全局变量使用-register-修饰" class="headerlink" title="C语言标准规定 不应该 使用 对全局变量使用 register 修饰"></a>C语言标准规定 不应该 使用 对全局变量使用 register 修饰</h1><p>但是gnu C 标准支持这个特性, clang不支持这个特性，同样的代码使用clang编译会报错<br>uboot 代码中 有如下宏<br><a href="https://gcc.gnu.org/onlinedocs/gcc/Global-Register-Variables.html">https://gcc.gnu.org/onlinedocs/gcc/Global-Register-Variables.html</a><br> using the volatile qualifier does not fully prevent the compiler from optimizing accesses to the register<br>在文件 uboot-2019.07&#x2F;arch&#x2F;riscv&#x2F;include&#x2F;asm&#x2F;global_data.h 有如下宏,</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE_GLOBAL_DATA_PTR register gd_t *gd asm (<span class="string">&quot;gp&quot;</span>)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的奇葩opensuse</title>
    <url>/2020/02/18/about-opensuse/</url>
    <content><![CDATA[<h2 id="安装完成之后的软件源切换"><a href="#安装完成之后的软件源切换" class="headerlink" title="安装完成之后的软件源切换"></a>安装完成之后的软件源切换</h2><ol>
<li>禁用所有软件源<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo zypper mr -da</span><br></pre></td></tr></table></figure></li>
<li>添加阿里镜像源<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo zypper ar -<span class="built_in">fc</span> https://mirrors.aliyun.com/opensuse/distribution/leap/15.1/repo/oss openSUSE-Aliyun-OSS ;</span><br><span class="line">$ sudo zypper ar -<span class="built_in">fc</span> https://mirrors.aliyun.com/opensuse/distribution/leap/15.1/repo/non-oss openSUSE-Aliyun-NON-OSS ;</span><br><span class="line">$ sudo zypper ar -<span class="built_in">fc</span> https://mirrors.aliyun.com/opensuse/update/leap/15.1/oss openSUSE-Aliyun-UPDATE-OSS ;</span><br><span class="line">$ sudo zypper ar -<span class="built_in">fc</span> https://mirrors.aliyun.com/opensuse/update/leap/15.1/non-oss openSUSE-Aliyun-UPDATE-NON-OSS ;</span><br></pre></td></tr></table></figure></li>
<li>手动刷新软件源<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo zypper ref</span><br></pre></td></tr></table></figure>
<h2 id="core-file-无法生成"><a href="#core-file-无法生成" class="headerlink" title="core file 无法生成"></a>core file 无法生成</h2>opensuse 默认无法产生 core file 需要查找官方文档 设置<h2 id="git-commit-failed"><a href="#git-commit-failed" class="headerlink" title="git commit failed"></a>git commit failed</h2>openusse  git 默认无配置文件， git commit 阻塞， 或者是使用了 奇怪的 编辑器。</li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>About OTP</title>
    <url>/2020/02/18/about-otp/</url>
    <content><![CDATA[<h2 id="什么是OTP"><a href="#什么是OTP" class="headerlink" title="什么是OTP"></a>什么是OTP</h2><p>One-Time-Programmable Memory (OTP)<br>Programmable Read Only Memory (PROM) and One-Time-Programmable (OTP) Memory can be written to once.<br>popularity<br>DESCRIPTION<br>While the memory contents for a ROM are set at design&#x2F;manufacturing time, Programmable Read Only memories (PROM) and more recently One-Time Programmable (OTP) devices can be programmed after manufacturing making them a lot more flexible. Once programmed, or blown, the contents cannot be changed and the contents are retained after power is removed.</p>
<p>The term “blown” is a historical term related to the programming mechanism of PROMs. Contents were written by using a high voltage to burn out interconnection fuses. These PROMs were blown on special devices called PROM Programmers.</p>
<p>The PROM was originally developed as part of a military program related to ICBMs in 1956. The invention is attributed to Wen Tsing Chow who was working for American Bosch Arma Corporation. Commercial devices became available in the late 1960s.</p>
<p>The integration of PROM technology into a standard CMOS processes is attributed to Kilopass Technology Inc. Kilopass has 1T, 2T and 3.5T antifuse bit cells and have been available since 2001. In 2005, Sidense developed a split channel antifuse 1T device. Synopsys has since acquired both Sidense and Kilopass</p>
]]></content>
      <tags>
        <tag>terms</tag>
      </tags>
  </entry>
  <entry>
    <title>about-poll-seletc</title>
    <url>/2021/08/26/about-poll-select/</url>
    <content><![CDATA[<p>平台特性<br>linux : select poll epool<br>windows: select</p>
]]></content>
  </entry>
  <entry>
    <title>About preprocess</title>
    <url>/2020/02/23/about-preprocess/</url>
    <content><![CDATA[<h1 id="预处理是C-x2F-C-编译过程中的第一个环节-处理以-开头的文本行"><a href="#预处理是C-x2F-C-编译过程中的第一个环节-处理以-开头的文本行" class="headerlink" title="预处理是C&#x2F;C++ 编译过程中的第一个环节, 处理以#开头的文本行"></a>预处理是C&#x2F;C++ 编译过程中的第一个环节, 处理以#开头的文本行</h1><ul>
<li>比如免费版和付费版的功能多少的条件编译</li>
<li>实现代码对于不同平台的兼容，或者对相同平台的不同版本进行兼容<h1 id="宏的作用常见的就是简单的文本替换功能，实现函数的替换，DEBUG版本加打印，release-版本不加打印"><a href="#宏的作用常见的就是简单的文本替换功能，实现函数的替换，DEBUG版本加打印，release-版本不加打印" class="headerlink" title="宏的作用常见的就是简单的文本替换功能，实现函数的替换，DEBUG版本加打印，release 版本不加打印"></a>宏的作用常见的就是简单的文本替换功能，实现函数的替换，DEBUG版本加打印，release 版本不加打印</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此代码来自 Learn C the hard way 一书</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __dbg_h__</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __dbg_h__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(M, ...)</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(M, ...) fprintf(stderr, <span class="string">&quot;DEBUG %s:%d: &quot;</span> M <span class="string">&quot;\n&quot;</span>, __</span></span><br><span class="line">FILE__, __LINE__, ##__VA_ARGS__)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clean_errno() (errno == 0 ? <span class="string">&quot;None&quot;</span> : strerror(errno))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_err(M, ...) fprintf(stderr, <span class="string">&quot;[ERROR] (%s:%d: errno:</span></span></span><br><span class="line"><span class="string"><span class="meta">%s) &quot;</span> M <span class="string">&quot;\n&quot;</span>, __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_warn(M, ...) fprintf(stderr, <span class="string">&quot;[WARN] (%s:%d: errno:</span></span></span><br><span class="line"><span class="string"><span class="meta">%s) &quot;</span> M <span class="string">&quot;\n&quot;</span>, __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> log_info(M, ...) fprintf(stderr, <span class="string">&quot;[INFO] (%s:%d) &quot;</span> M <span class="string">&quot;\n&quot;</span></span></span><br><span class="line">, __FILE__, __LINE__, ##__VA_ARGS__)</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> check(A, M, ...) <span class="keyword">if</span>(!(A)) &#123; log_err(M, ##__VA_ARGS__); e</span></span><br><span class="line">rrno=<span class="number">0</span>; <span class="keyword">goto</span> error; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> sentinel(M, ...) &#123; log_err(M, ##__VA_ARGS__); errno=0;</span></span><br><span class="line"><span class="keyword">goto</span> error; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> check_mem(A) check((A), <span class="string">&quot;Out of memory.&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> check_debug(A, M, ...) <span class="keyword">if</span>(!(A)) &#123; debug(M, ##__VA_ARGS__</span></span><br><span class="line">); errno=<span class="number">0</span>; <span class="keyword">goto</span> error; &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="字符串化输入"><a href="#字符串化输入" class="headerlink" title="字符串化输入"></a>字符串化输入</h1>　　# 可以实现将输入的内容字符串化<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STR(input)  #input</span></span><br></pre></td></tr></table></figure>
<h1 id="粘贴两个字符串"><a href="#粘贴两个字符串" class="headerlink" title="粘贴两个字符串"></a>粘贴两个字符串</h1>　　## 可以粘贴两个字符串<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STRPASTE(str1, str2)  str1##str2</span></span><br></pre></td></tr></table></figure>
<h1 id="宏函数的嵌套调用翻译过程"><a href="#宏函数的嵌套调用翻译过程" class="headerlink" title="宏函数的嵌套调用翻译过程"></a>宏函数的嵌套调用翻译过程</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(ANDROID1) &amp;&amp; defined(ANDROID2)</span></span><br><span class="line"><span class="type">int</span> android = <span class="number">12</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> ANDROID2</span></span><br><span class="line"><span class="type">int</span> android = <span class="number">12</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">int</span> android = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span><span class="comment">// end of android2</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ANDROID1</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ANDROID2</span></span><br><span class="line"><span class="type">int</span> android  =<span class="number">12</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">int</span> android = <span class="number">1</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ANDROID9 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STRINGLIZE(input)  #input</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CATSTRINGS(str1, str2) str1##str2</span></span><br></pre></td></tr></table></figure>
<h1 id="预处理中常见的关键字，和写法"><a href="#预处理中常见的关键字，和写法" class="headerlink" title="预处理中常见的关键字，和写法"></a>预处理中常见的关键字，和写法</h1></li>
</ul>
<ol>
<li>注释代码<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="comment">// temperatory deleted code or debug/test code</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="comment">//调试代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">//非调试代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="常见问题，注意事项"><a href="#常见问题，注意事项" class="headerlink" title="常见问题，注意事项"></a>常见问题，注意事项</h1></li>
</ol>
<ul>
<li>不要让临时变量污染函数空间,使用do{}while(0) 的宏来做到这点</li>
<li>定义宏函数的时候多使用括号，因为宏是简单的文本替换</li>
</ul>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>about-program-languages</title>
    <url>/2021/09/05/about-program-languages/</url>
    <content><![CDATA[<h1 id="编程语言分类标准很多-语言也有很多-每一种流传的语言的创建大多都有一些哲学思辨"><a href="#编程语言分类标准很多-语言也有很多-每一种流传的语言的创建大多都有一些哲学思辨" class="headerlink" title="编程语言分类标准很多,语言也有很多,每一种流传的语言的创建大多都有一些哲学思辨"></a>编程语言分类标准很多,语言也有很多,每一种流传的语言的创建大多都有一些哲学思辨</h1><h1 id="面向过程-面向对象"><a href="#面向过程-面向对象" class="headerlink" title="面向过程, 面向对象"></a>面向过程, 面向对象</h1><h1 id="编译型-解释型"><a href="#编译型-解释型" class="headerlink" title="编译型,解释型"></a>编译型,解释型</h1><h1 id="函数式"><a href="#函数式" class="headerlink" title="函数式"></a>函数式</h1><h1 id="C-C-x2F-Java-x2F-NET"><a href="#C-C-x2F-Java-x2F-NET" class="headerlink" title="C, C++&#x2F;Java&#x2F;.NET"></a>C, C++&#x2F;Java&#x2F;.NET</h1><h1 id="Python-x2F-Java-x2F-C-x2F-Lisp"><a href="#Python-x2F-Java-x2F-C-x2F-Lisp" class="headerlink" title="Python&#x2F;Java&#x2F;C++&#x2F;Lisp"></a>Python&#x2F;Java&#x2F;C++&#x2F;Lisp</h1><h1 id="Haskell"><a href="#Haskell" class="headerlink" title="Haskell"></a>Haskell</h1>]]></content>
  </entry>
  <entry>
    <title>About Protocol</title>
    <url>/2021/09/04/about-protocol/</url>
    <content><![CDATA[<h1 id="常见的协议和不常见的协议"><a href="#常见的协议和不常见的协议" class="headerlink" title="常见的协议和不常见的协议"></a>常见的协议和不常见的协议</h1><ol>
<li>AOA协议android上，谷歌定义的协议</li>
<li>Xmodem协议,基于UART的文件传输协议</li>
<li>NFS协议</li>
<li>RPC协议</li>
<li>HTTP协议</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>About pwd</title>
    <url>/2020/01/28/about-pwd/</url>
    <content><![CDATA[<h1 id="关于工作路径"><a href="#关于工作路径" class="headerlink" title="关于工作路径"></a>关于工作路径</h1><p>　　工作路径是进程的一个重要的属性，在pcb结构中应该是一项成员，平时和文件交互的比较少的业务很少会关注程序的工作路径的问题</p>
<h1 id="情形"><a href="#情形" class="headerlink" title="情形"></a>情形</h1><p>　　为了适配不同的厂商或者版本，想要后台程序通过读取配置文件方法来，减少某个组件编译次数, 每次厂商变更只需要改下配置文件中的厂商名字就行了，不必要在代码中写死，每次都要换个厂都要加个宏，在代码中加入一个常量</p>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>　　Android后台程序(为方便设置为daemon.exe位于&#x2F;system&#x2F;bin&#x2F;目录下)daemon.exe开机启动的时候要读取&#x2F;system&#x2F;bin&#x2F;下的product.conf文配置文件.</p>
<h1 id="代码实现-主要代码就是打开文件的地方，然后调用系统的解析取配置文件的接口，读取配置文件是一个有意思的小项目，可以自己实现一次"><a href="#代码实现-主要代码就是打开文件的地方，然后调用系统的解析取配置文件的接口，读取配置文件是一个有意思的小项目，可以自己实现一次" class="headerlink" title="代码实现 主要代码就是打开文件的地方，然后调用系统的解析取配置文件的接口，读取配置文件是一个有意思的小项目，可以自己实现一次"></a>代码实现 主要代码就是打开文件的地方，然后调用系统的解析取配置文件的接口，读取配置文件是一个有意思的小项目，可以自己实现一次</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Linux 环境中包含 &lt;unistd.h&gt;头文件可以使用</span><br><span class="line">getcwd, getwd, get_current_dir_name 获取程序的当前工作路径</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="type">char</span> *<span class="title">getcwd</span><span class="params">(<span class="type">char</span> *buf, <span class="type">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="type">char</span> *<span class="title">getwd</span><span class="params">(<span class="type">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="type">char</span> *<span class="title">get_current_dir_name</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_FILE_PATH <span class="string">&quot;./product.conf&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">app_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 省略若干行代码...</span></span><br><span class="line">  FILE *fp = <span class="built_in">fopen</span>(CONFIG_FILE_PATH, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;fopen error&quot;</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">char</span> *current_work_dir = <span class="built_in">get_current_dir_name</span>();</span><br><span class="line">  <span class="keyword">if</span> (current_work_dir != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;current working dir is [%s]&quot;</span>, current_work_dir);</span><br><span class="line">      <span class="built_in">free</span>(current_work_dir);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 省略若干行代码...</span></span><br><span class="line">  <span class="keyword">if</span> (fp != <span class="literal">NULL</span>)</span><br><span class="line">  <span class="built_in">fclose</span>(fp);</span><br><span class="line"><span class="comment">// 省略若干行代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="问题出现之后我的直觉告诉先打印errno-然后猜测可能是工作路径的问题就，调用系统的函数获取不同情境下的工作路径"><a href="#问题出现之后我的直觉告诉先打印errno-然后猜测可能是工作路径的问题就，调用系统的函数获取不同情境下的工作路径" class="headerlink" title="问题出现之后我的直觉告诉先打印errno, 然后猜测可能是工作路径的问题就，调用系统的函数获取不同情境下的工作路径"></a>问题出现之后我的直觉告诉先打印errno, 然后猜测可能是工作路径的问题就，调用系统的函数获取不同情境下的工作路径</h2><p>手里没有root权限的android 手机，就使用linux，linux中开机拉起服务的地方加入自己写的程序的路径</p>
<p>#附加题：如何创建守护进程？ 参考 APUE</p>
<ol>
<li>通过fork 创建子进程</li>
<li>子进程kill 父进程</li>
<li>设置自己的工作路径</li>
<li></li>
</ol>
<p>这个时候是采用绝对路径，还是相对路径<br>项目中的程序位于 &#x2F;system&#x2F;bin 下配置文件也在同一级文件目录中。<br>程序开机由系统脚本拉起后常驻后台，检测其他进程.</p>
<p>首先设为绝对路径，.&#x2F;exe 拉起 测试ok,系统脚本拉起也ok,但是同事A认为同一级目录下 直接读取文件名就可以了，<br>听命令改，.&#x2F;exe 测试ok ,然而系统脚本拉起之后整个系统无法正常运行，因为配置文件没有读取到，程序报出错误打印<br>经过测试，Android init.rc 中拉起的程序工作路径是&#x2F; ，而非程序所在目录，当使用 .&#x2F;exe 拉起程序的时候工作路径在当前目录<br>使用相对路径自然找到配置文件</p>
]]></content>
      <tags>
        <tag>Linux/C</tag>
      </tags>
  </entry>
  <entry>
    <title>About python</title>
    <url>/2020/02/18/about-python/</url>
    <content><![CDATA[<h1 id="Python-是Guido-van-Rossum-圣诞节无聊发明的一种编程语言"><a href="#Python-是Guido-van-Rossum-圣诞节无聊发明的一种编程语言" class="headerlink" title="Python 是Guido van Rossum 圣诞节无聊发明的一种编程语言"></a>Python 是Guido van Rossum 圣诞节无聊发明的一种编程语言</h1><p>特征</p>
<ul>
<li>非强制面向对象</li>
<li>动态类型</li>
<li>脚本(解释型)语言</li>
<li>类C语法</li>
<li>语法块按照对齐产生<h1 id="python-三种实现"><a href="#python-三种实现" class="headerlink" title="python 三种实现"></a>python 三种实现</h1></li>
<li>cpython C </li>
<li>jpython Java</li>
<li>IronPython .NET</li>
</ul>
<h1 id="python-优化方法"><a href="#python-优化方法" class="headerlink" title="python 优化方法"></a>python 优化方法</h1><ol>
<li>使用pypy python版的python解释器</li>
<li>shed skin 将python代码转换成c++的代码</li>
</ol>
<h1 id="python-工具"><a href="#python-工具" class="headerlink" title="python 工具"></a>python 工具</h1><p>pyvenv</p>
<h1 id="python中的不可变类型"><a href="#python中的不可变类型" class="headerlink" title="python中的不可变类型"></a>python中的不可变类型</h1><p>Interger, string, tuple</p>
<h1 id="变量名没有类型，对象有类型"><a href="#变量名没有类型，对象有类型" class="headerlink" title="变量名没有类型，对象有类型"></a>变量名没有类型，对象有类型</h1><p>slice切片操作<br>list [],<br>tuple（）</p>
<h1 id="创建自测试的模块"><a href="#创建自测试的模块" class="headerlink" title="创建自测试的模块"></a>创建自测试的模块</h1><p>在模块的尾部加入以下代码<br>if <strong>name</strong> &#x3D;&#x3D; ‘<strong>main</strong>‘:<br>    import doctest<br>    doctest.testmod()<br>此模块在python解释器中直接运行时候就能进行doctest</p>
]]></content>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>about repo</title>
    <url>/2020/02/18/about-repo/</url>
    <content><![CDATA[<h1 id="什么是repo"><a href="#什么是repo" class="headerlink" title="什么是repo"></a>什么是repo</h1><p>Repo 简化了跨多个代码库运行的流程，与 Git 相辅相成。请参阅源代码控制工具，了解有关 Repo 和 Git 之间关系的说明。如需详细了解 Repo，请参阅 Repo 命令参考资料和 Repo README。</p>
<h1 id="repo-命令格式"><a href="#repo-命令格式" class="headerlink" title="repo 命令格式"></a>repo 命令格式</h1><p>使用 Repo 需遵循的格式如下：</p>
<p>repo command options</p>
<p>可选元素显示在方括号 [ ] 中。例如，许多命令会用到项目列表 (project-list) 参数。项目列表可以是一个名称列表，也可以是一个本地源代码目录的路径列表：</p>
<h1 id="repo-的命令使用"><a href="#repo-的命令使用" class="headerlink" title="repo 的命令使用"></a>repo 的命令使用</h1><p>repo sync [project0 project1 … projectn]<br>repo sync [&#x2F;path&#x2F;to&#x2F;project0 … &#x2F;path&#x2F;to&#x2F;projectn]</p>
<p>help<br>安装 Repo 后，您可以通过运行以下命令找到最新文档（开头是包含所有命令的摘要）：</p>
<p>repo help</p>
<p>您可以通过在 Repo 树中运行以下命令来获取有关某个命令的信息：</p>
<p>repo help command</p>
<p>例如，以下命令会生成 Repo init 参数的说明和选项列表，该参数会在当前目录中初始化 Repo（要了解详情，请参阅 init）。</p>
<p>repo help init</p>
<p>init<br>repo init -u url [options]</p>
<p>在当前目录中安装 Repo。这样会创建一个 .repo&#x2F; 目录，其中包含 Repo 源代码和标准 Android 清单文件的 Git 代码库。该 .repo&#x2F; 目录中还包含 manifest.xml，该文件是一个指向 .repo&#x2F;manifests&#x2F; 目录中所选清单的符号链接。有关更新清单的说明，请参阅 manifest-format.md。</p>
<p>选项：</p>
<p>-u：指定要从中检索清单代码库的网址。您可以在 <a href="https://android.googlesource.com/platform/manifest">https://android.googlesource.com/platform/manifest</a> 中找到通用清单。<br>-m：选择代码库中的一个清单文件。如果未选择任何清单名称，则会默认选择 default.xml。<br>-b：指定修订版本，即特定的清单分支。<br>注意：对于其余的所有 Repo 命令，当前工作目录必须是 .repo&#x2F; 的父目录或该父目录的子目录。</p>
<p>sync<br>repo sync [project-list]</p>
<p>下载新的更改并更新本地环境中的工作文件。如果您在未使用任何参数的情况下运行 repo sync，则该操作会同步所有项目的文件。</p>
<p>运行 repo sync 后，将出现以下情况：</p>
<p>如果目标项目从未同步过，则 repo sync 相当于 git clone。远程代码库中的所有分支都会复制到本地项目目录中。</p>
<p>如果目标项目以前同步过，则 repo sync 相当于以下命令：</p>
<p>git remote update<br>git rebase origin&#x2F;branch</p>
<p>其中 branch 是本地项目目录中当前已检出的分支。如果本地分支没有在跟踪远程代码库中的分支，则项目不会发生任何同步。</p>
<p>如果 Git rebase 操作导致合并冲突，请使用常规 Git 命令（例如 git rebase –continue）解决冲突。</p>
<p>repo sync 运行成功后，指定项目中的代码即处于最新状态，已与远程代码库中的代码同步。</p>
<p>选项：</p>
<p>-d：将指定项目切换回清单修订版本。如果项目当前属于某个主题分支，但临时需要清单修订版本，则此选项会有所帮助。</p>
<p>-s：同步到当前清单中的 manifest-server 元素指定的一个已知良好版本。</p>
<p>-f：即使某个项目同步失败，也继续同步其他项目。</p>
<p>upload<br>repo upload [project-list]</p>
<p>对于指定的项目，Repo 会将本地分支与最后一次 repo sync 时更新的远程分支进行比较。Repo 会提示您选择一个或多个尚未上传以供审核的分支。</p>
<p>接下来，所选分支上的所有提交都会通过 HTTPS 连接传输到 Gerrit。您需要配置一个 HTTPS 密码以启用上传授权。要生成新的用户名&#x2F;密码对以用于 HTTPS 传输，请访问密码生成器。</p>
<p>当 Gerrit 通过其服务器接收对象数据时，它会将每项提交转变成一项更改，以便审核者可以针对特定提交给出意见。要将几项“检查点”提交合并为一项提交，请使用 git rebase -i，然后再运行 upload。</p>
<p>如果您在未使用任何参数的情况下运行 repo upload，则该操作会搜索所有项目中的更改以进行上传。</p>
<p>要在更改上传后对其进行修改，请使用 git rebase -i 或 git commit –amend 等工具更新您的本地提交。修改完成之后，请执行以下操作：</p>
<p>进行验证以确保更新后的分支是当前已检出的分支。<br>对于相应系列中的每项提交，请在方括号内输入 Gerrit 更改 ID：</p>
<h1 id="Replacing-from-branch-foo"><a href="#Replacing-from-branch-foo" class="headerlink" title="Replacing from branch foo"></a>Replacing from branch foo</h1><p>[ 3021 ] 35f2596c Refactor part of GetUploadableBranches to lookup one specific…<br>[ 2829 ] ec18b4ba Update proto client to support patch set replacments</p>
<h1 id="Insert-change-numbers-in-the-brackets-to-add-a-new-patch-set"><a href="#Insert-change-numbers-in-the-brackets-to-add-a-new-patch-set" class="headerlink" title="Insert change numbers in the brackets to add a new patch set."></a>Insert change numbers in the brackets to add a new patch set.</h1><h1 id="To-create-a-new-change-record-leave-the-brackets-empty"><a href="#To-create-a-new-change-record-leave-the-brackets-empty" class="headerlink" title="To create a new change record, leave the brackets empty."></a>To create a new change record, leave the brackets empty.</h1><p>上传完成后，这些更改将拥有一个额外的补丁程序集。</p>
<p>如果您希望只上传当前已检出的 Git 分支，则可以使用标记 –current-branch（简称 –cbr）。</p>
<p>diff<br>repo diff [project-list]</p>
<p>使用 git diff 显示提交与工作树之间的明显更改。</p>
<p>download<br>repo download target change</p>
<p>从审核系统中下载指定更改，并放在您项目的本地工作目录中供使用。</p>
<p>例如，要将更改 23823 下载到您的 platform&#x2F;build 目录，请运行以下命令：</p>
<p>repo download platform&#x2F;build 23823</p>
<p>运行 repo sync 会删除使用 repo download 检索到的任何提交。或者，您可以使用 git checkout m&#x2F;master 检出远程分支。</p>
<p>注意：由于全球的所有服务器均存在复制延迟，因此某项更改出现在网络上（位于 Gerrit 中）的时间与所有用户可通过 repo download 找到此项更改的时间之间存在些许的镜像延迟。</p>
<p>forall<br>repo forall [project-list] -c command</p>
<p>在每个项目中运行指定的 shell 命令。通过 repo forall 可使用下列额外的环境变量：</p>
<p>REPO_PROJECT 设为了项目的唯一名称。</p>
<p>REPO_PATH 是相对于客户端根目录的路径。</p>
<p>REPO_REMOTE 是清单中远程系统的名称。</p>
<p>REPO_LREV 是清单中修订版本的名称，已转换为本地跟踪分支。如果您需要将清单修订版本传递到某个本地运行的 Git 命令，则可使用此变量。</p>
<p>REPO_RREV 是清单中修订版本的名称，与清单中显示的名称完全一致。</p>
<p>选项：</p>
<p>-c：要运行的命令和参数。此命令会通过 &#x2F;bin&#x2F;sh 进行评估，它之后的任何参数都将作为 shell 位置参数传递。</p>
<p>-p：在所指定命令的输出结果之前显示项目标头。这通过以下方式实现：将管道绑定到命令的 stdin、stdout 和 sterr 流，然后通过管道将所有输出结果传输到一个分页会话中显示的连续流中。</p>
<p>-v：显示该命令向 stderr 写入的消息。</p>
<p>prune<br>repo prune [project-list]</p>
<p>删减（删除）已合并的主题。</p>
<p>start<br>repo start<br>branch-name [project-list]</p>
<p>从清单中指定的修订版本开始，创建一个新的分支进行开发。</p>
<p>BRANCH_NAME 参数用于简要说明您尝试对项目进行的更改。如果您不知道，则不妨考虑使用名称 default。</p>
<p>project-list 参数指定了将参与此主题分支的项目。</p>
<p>注意：句点 (.) 是一个简写形式，用来代表当前工作目录中的项目。</p>
<p>status<br>repo status [project-list]</p>
<p>对于每个指定的项目，将工作树与临时区域（索引）以及此分支 (HEAD) 上的最近一次提交进行比较。在这三种状态存在差异之处显示每个文件的摘要行。</p>
<p>要仅查看当前分支的状态，请运行 repo status。系统会按项目列出状态信息。对于项目中的每个文件，系统使用两个字母的代码来表示：</p>
<p>在第一列中，大写字母表示临时区域与上次提交状态之间的不同之处。</p>
<p>字母    含义    说明</p>
<ul>
<li>没有变化    在 HEAD 与索引中相同<br>A    已添加    不存在于 HEAD 中，但存在于索引中<br>M    已修改    存在于 HEAD 中，但索引中的文件已修改<br>D    已删除    存在于 HEAD 中，但不存在于索引中<br>R    已重命名    不存在于 HEAD 中，索引中文件的路径已更改<br>C    已复制    不存在于 HEAD 中，复制自索引中的另一个文件<br>T    模式已更改    HEAD 与索引中的内容相同，但模式已更改<br>U    未合并    HEAD 与索引之间存在冲突；需要加以解决<br>在第二列中，小写字母表示工作目录与索引之间的不同之处。</li>
</ul>
<p>字母    含义    说明</p>
<ul>
<li>新&#x2F;未知    不存在于索引中，但存在于工作树中<br>m    已修改    存在于索引中，也存在于工作树中（但已修改）<br>d    已删除    存在于索引中，但不存在于工作树中</li>
</ul>
<h1 id="repo-上传代码-到-gerrit"><a href="#repo-上传代码-到-gerrit" class="headerlink" title="repo 上传代码 到 gerrit"></a>repo 上传代码 到 gerrit</h1><p>新建一个 Repo 分支<br>对于您打算进行的每项更改，请在相关的 Git 存储库中新建一个分支：</p>
<p>repo start NAME .</p>
<p>您可以在同一存储库中同时新建多个独立的分支。“NAME”分支是您的工作区的本地分支，不会包含在 Gerrit 或最终源代码树中。</p>
<p>进行更改<br>在您修改源代码文件（并且验证）后，请将这些更改提交到您的本地存储库：</p>
<p>git add -A<br>git commit -s</p>
<p>请在您的提交消息中提供相关更改的详细说明。该说明将会被推送到公开 AOSP 存储库，因此请按照我们的准则来撰写更改列表说明：</p>
<p>以一行摘要（最多 50 个字符）开头，后跟一个空白行。 这是 Git 和 Gerrit 支持的格式，适用于各种屏幕尺寸的设备。</p>
<p>从第三行开始输入较长的说明，说明会在达到 72 个字符时自动硬回车换行。该部分应着重说明更改解决了什么问题，以及如何解决了问题。尽管我们建议您提供第二部分的内容，但这在实现新功能时是可选内容。</p>
<p>添加对任何假设或背景信息的简短说明，这些内容可能对下一年研究此功能的其他贡献者起到很大的帮助作用。</p>
<p>以下是一个示例提交消息：</p>
<p>short description on first line</p>
<p>more detailed description of your patch,<br>which is likely to take up multiple lines.</p>
<p>repo init 期间提供的唯一更改 ID 以及您的姓名和电子邮件将自动添加到您的提交消息中。</p>
<p>上传到 Gerrit<br>将更改提交到您的个人历史记录后，请使用以下命令将其上传到 Gerrit：</p>
<p>repo upload</p>
<p>如果您在同一存储库中新建了多个分支，则系统会提示您选择要上传的分支。</p>
<p>上传成功后，Repo 会为您提供 Gerrit 上对应新页面的网址。访问该链接可在审核服务器上查看您上传的补丁程序、添加注释，或者为您的补丁程序申请特定审核者。</p>
<p>上传替换补丁程序<br>假设某位审核者已看过您的补丁程序，并要求您做一些小小的修改。您可以在 Git 中修改提交的内容，这会在 Gerrit 中生成一个新的补丁程序，该补丁程序与原始补丁程序具有相同的更改 ID。</p>
<p>注意：如果您在上传该补丁程序之后进行了其他提交，那么您将需要手动移动 Git HEAD。<br>git add -A<br>git commit –amend</p>
<p>当您上传修改后的补丁程序时，它将替换 Gerrit 和本地 Git 历史记录中的原始补丁程序。</p>
<p>解决同步冲突<br>如果提交到源代码树的其他补丁程序与您的存在冲突，那么您需要在源代码存储库的新 HEAD 的基础上对您的补丁程序执行“衍合”(rebase) 命令。执行此操作的一种简单方法是运行以下命令：</p>
<p>repo sync</p>
<p>此命令首先从源代码服务器获取更新，然后尝试在新的远程 HEAD 的基础上对您的 HEAD 自动执行衍合命令。</p>
<p>如果自动衍合命令失败，您就必须手动执行衍合。</p>
<p>repo rebase</p>
<p>使用 git mergetool 可帮助您处理衍合冲突。在成功合并冲突文件后，运行以下命令：</p>
<p>git rebase –continue</p>
<p>在自动或手动衍合完成之后，运行 repo upload 来提交衍合后的补丁程序。</p>
]]></content>
  </entry>
  <entry>
    <title>About Shell</title>
    <url>/2020/01/19/about-shell/</url>
    <content><![CDATA[<h1 id="shell-直译为壳"><a href="#shell-直译为壳" class="headerlink" title="shell 直译为壳"></a>shell 直译为壳</h1><p>　　有个著名的油气公司叫做荷兰皇家壳牌（英語：Royal Dutch Shell Plc）是世界第二大石油公司，公司在英國註冊，总部位于荷兰海牙。<br>外国人什么都叫做壳，蛋壳，地壳，都是shell 有种包裹什么东西在里面的感觉<br>操作系统分为内核和外壳 这个壳叫做shell, shell 用来和内核交流，shell 有CUI(命令行的), GUI (图形化的).<br>unix&#x2F;linux&#x2F;freebsd 操作系统上最通用的人机交互界面就是命令行，典型 windows上最常用的是 图形化界面(忘记了一个gui系统的几个基本元素mouse ,window, focus,)<br>下面主要讨论 命令行shell</p>
<h1 id="格式各样的shell"><a href="#格式各样的shell" class="headerlink" title="格式各样的shell"></a>格式各样的shell</h1><p>　　常见的bash，sh, zsh,fish (经常听说 bash 4.xx 有什么命令注入漏洞)<br>ash :<br>bash(Bourne-Again SHell) :比较流行的一个shell基本各大linux发行版本都默认设置bash为shell<br>zsh ：号称最后一个shell 因为字母 z是最后一个了。。<br>fish : 灵活的交互式shell, 自动补全的特性很强大</p>
<p>Bash is the shell, or command language interpreter, for the GNU operating system. The name is an acronym for the ‘ Bourne-Again SHell ‘, a pun on Stephen Bourne, the author of the direct ancestor of the current Unix shell sh , which appeared in the Seventh Edition Bell Labs Research version of Unix.<br>The C shell (csh or the improved version, tcsh) is a Unix shell created by Bill Joy while he was a graduate student at University of California, Berkeley in the late 1970s.<br>The Bourne shell (sh) is a shell, or command-line interpreter, for computer operating systems.<br>The Bourne shell was the default shell for Version 7 Unix. Many Unix-like systems continue to have &#x2F;bin&#x2F;sh—which will be the Bourne shell, or a symbolic link or hard link to a compatible shell—even when other shells are used by most users.<br>KornShell (ksh) is a Unix shell which was developed by David Korn at Bell Labs in the early 1980s and announced at USENIX on July 14, 1983.[1][2] The initial development was based on Bourne shell source code.[7]</p>
<p>dash (Debian Almquist shell)</p>
<h2 id="bash-的奇技淫巧"><a href="#bash-的奇技淫巧" class="headerlink" title="bash 的奇技淫巧"></a>bash 的奇技淫巧</h2><p>　　挖坑待填</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>About sizeof</title>
    <url>/2020/01/24/about-sizeof/</url>
    <content><![CDATA[<h1 id="sizeof-的误解，sizeof-不是函数-function-，是运算符-operator"><a href="#sizeof-的误解，sizeof-不是函数-function-，是运算符-operator" class="headerlink" title="sizeof 的误解，sizeof 不是函数(function)，是运算符(operator)"></a>sizeof 的误解，sizeof 不是函数(function)，是运算符(operator)</h1><p>　　函数在程序运行的时候起作用，运算符求出来的大小是在编译时就确定下来的</p>
<h2 id="常见的sizeof操作"><a href="#常见的sizeof操作" class="headerlink" title="常见的sizeof操作"></a>常见的sizeof操作</h2><ul>
<li><p>对结构体类型求大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> *ptr;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">19</span>];</span><br><span class="line">&#125; Demo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体的实际所占用内存大小，需要内存对齐，按照4byte或者8byte对齐，</span></span><br><span class="line"><span class="comment">// 对齐的原则整体大小能被4整除，而且每个成员的地址偏移都是4的整数倍</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">sizeof</span>(Demo) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
<li><p>对联合体求大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 联合体的大小是能够容纳最大的成员的大小, 还要考虑一下四字节对齐</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> &#123;</span><br><span class="line">  <span class="type">int</span> a[<span class="number">3</span>];</span><br><span class="line">  <span class="type">char</span> b[<span class="number">8</span>] ;</span><br><span class="line">&#125; data;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sizeof(data)= %d\n&quot;</span>, <span class="built_in">sizeof</span>(data)); <span class="comment">// 12</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对字符串常量求大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">char</span> p2[] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> sz1 = <span class="built_in">sizeof</span>(<span class="string">&quot;mute&quot;</span>);</span><br><span class="line"><span class="type">int</span> len1 = <span class="built_in">strlen</span>(<span class="string">&quot;mute&quot;</span>);</span><br><span class="line"><span class="type">int</span> sz2 = <span class="built_in">sizeof</span>(p1);</span><br><span class="line"><span class="type">int</span> sz3 = <span class="built_in">sizeof</span>(p2);</span><br><span class="line"><span class="type">int</span> len2 = <span class="built_in">strlen</span>(p1);</span><br><span class="line"><span class="type">int</span> len3 = <span class="built_in">strlen</span>(p2);</span><br></pre></td></tr></table></figure></li>
<li><p>对指针变量、指针类型求大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span>* ptr = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="type">int</span> sz1 = <span class="built_in">sizeof</span>(ptr);</span><br><span class="line"><span class="type">int</span> sz2 = <span class="built_in">sizeof</span>(<span class="type">char</span>*);</span><br><span class="line"><span class="type">int</span> sz3 = <span class="built_in">sizeof</span>(*ptr);</span><br><span class="line"><span class="comment">// x64 平台结果是881 指针类型解引用之后的大小就是*前面类型的大小</span></span><br><span class="line">std::cout &lt;&lt; sz1 &lt;&lt; sz2 &lt;&lt; sz3 &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">// 通常来说sizeof 对指针类型(变量)求值x86(32bit)平台就是4Btye,x64平台就算是8Byte</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对含有虚函数的class求大小</p>
</li>
<li><p>求数组的大小 、对变量求大小、 对类型求大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> array[] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(array) / <span class="built_in">sizeof</span>(<span class="type">int</span>); i++) &#123;</span><br><span class="line">    std::cout &lt;&lt; array[i] &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">sizeof</span>(array) / <span class="built_in">sizeof</span>(array[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">    std::cout &lt;&lt; array[i] &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>sizeof 的一个考题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line">  <span class="type">char</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="comment">//x86 windows (char *) type 4byte ,x64 windwows (char *)type 8bytes</span></span><br><span class="line">    <span class="type">char</span> **b[<span class="number">3</span>][<span class="number">4</span>]; <span class="comment">// 指针数组，12个元素，每个指针大小4或者8</span></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(MyStruct)= &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(MyStruct) &lt;&lt; endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(a)&quot;</span> &lt;&lt;<span class="built_in">sizeof</span>(a) &lt;&lt; endl; </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;sizeof(b)&quot;</span> &lt;&lt;<span class="built_in">sizeof</span>(b) &lt;&lt; endl; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sizeof-的原理"><a href="#sizeof-的原理" class="headerlink" title="sizeof 的原理"></a>sizeof 的原理</h2><p><a href="https://www.zhihu.com/question/26090484">参考知乎用户**<em>蓝色</em>**的回答</a></p>
<h2 id="x按n字节对齐的宏的来源"><a href="#x按n字节对齐的宏的来源" class="headerlink" title="x按n字节对齐的宏的来源"></a>x按n字节对齐的宏的来源</h2><p>x &#x3D; nq + r, 其中  0 &lt;&#x3D; r &lt; n                  &#x2F;&#x2F;最小非负剩余</p>
</li>
</ul>
<p>q, r 是唯一确定的。q &#x3D; [x&#x2F;n], r &#x3D; x - n[x&#x2F;n]. 这个是带余除法的一个简单形式。在 c 语言中， q, r 容易计算出来： q &#x3D; x&#x2F;n, r &#x3D; x % n.</p>
<p>所谓把 x 按 n 对齐指的是：若 r&#x3D;0, 取 qn, 若 r&gt;0, 取 (q+1)n. 这也相当于把 x 表示为：</p>
<p>x &#x3D; nq + r’, 其中 -n &lt; r’ &lt;&#x3D;0                &#x2F;&#x2F;最大非正剩余   </p>
<p>nq 是我们所求。关键是如何用 c 语言计算它。由于我们能处理标准的带余除法，所以可以把这个式子转换成一个标准的带余除法，<br>然后加以处理：</p>
<p>x+n &#x3D; qn + (n+r’)，其中 0&lt;n+r’&lt;&#x3D;n            &#x2F;&#x2F;最大正剩余</p>
<p>x+n-1 &#x3D; qn + (n+r’-1), 其中 0&lt;&#x3D; n+r’-1 &lt;n    &#x2F;&#x2F;最小非负剩余</p>
<p>所以 qn &#x3D; [(x+n-1)&#x2F;n]n. 用 c 语言计算就是：</p>
<p>((x+n-1)&#x2F;n)*n</p>
<p>若 n 是 2 的方幂, 比如 2^m，则除为右移 m 位，乘为左移 m 位。所以把 x+n-1 的最低 m 个二进制位清 0就可以了。得到：</p>
<p>(x+n-1) &amp; ~(n-1)</p>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>about-socket</title>
    <url>/2020/03/30/about-socket/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>sql 语句入门</title>
    <url>/2021/08/24/about-sql/</url>
    <content><![CDATA[<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">wakeup_source ,<span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span></span><br><span class="line">waekup_source_counter</span><br><span class="line">WHICH  production_version </span><br><span class="line"><span class="keyword">LIKE</span>  &quot;nwe-10%&quot;</span><br><span class="line"><span class="keyword">AND</span>  production_version </span><br><span class="line"><span class="keyword">LIKE</span> &quot;%211%&quot;</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> waekup_source_counter DES</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title>about-sqlite3</title>
    <url>/2020/03/28/about-sqlite3/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>about-ssh</title>
    <url>/2020/02/19/about-ssh/</url>
    <content><![CDATA[<h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><p>  Secure Shell (SSH) is a cryptographic network protocol for operating network services securely over an unsecured network</p>
<h1 id="ssh-也是Linux-命令之一，用于-取代telnet等不安全的协议软件-安全连接访问远程服务器"><a href="#ssh-也是Linux-命令之一，用于-取代telnet等不安全的协议软件-安全连接访问远程服务器" class="headerlink" title="ssh 也是Linux 命令之一，用于(取代telnet等不安全的协议软件)安全连接访问远程服务器."></a>ssh 也是Linux 命令之一，用于(取代telnet等不安全的协议软件)安全连接访问远程服务器.</h1><p>  ssh 基本用法 以root用户通过端口22333登录192.168.23.4主机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh root@192.168.23.4:2233  </span><br></pre></td></tr></table></figure>
<h1 id="ssh的特殊姿势"><a href="#ssh的特殊姿势" class="headerlink" title="ssh的特殊姿势"></a>ssh的特殊姿势</h1><p>  只有你拥有台海外vps并且安装了ssh服务，可以通过ssh动态端口转发实现fq</p>
<p>  ssh [-D [bind_address:]port root@remotehost:2233</p>
<p>  一般bind_address 是localhost</p>
<h1 id="netstat-nat-查看端口使用情况"><a href="#netstat-nat-查看端口使用情况" class="headerlink" title="netstat -nat 查看端口使用情况"></a>netstat -nat 查看端口使用情况</h1><h1 id="ssh-相关命令"><a href="#ssh-相关命令" class="headerlink" title="ssh 相关命令"></a>ssh 相关命令</h1><p>ssh-agent</p>
<p>ssh-keygen</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>About Thread</title>
    <url>/2020/01/24/about-thread/</url>
    <content><![CDATA[<h1 id="多线程编程是实用程序必然要用到的工具-没有多线程、多进程编程就不是现代编程人员做的事情"><a href="#多线程编程是实用程序必然要用到的工具-没有多线程、多进程编程就不是现代编程人员做的事情" class="headerlink" title="多线程编程是实用程序必然要用到的工具 没有多线程、多进程编程就不是现代编程人员做的事情"></a>多线程编程是实用程序必然要用到的工具 没有多线程、多进程编程就不是现代编程人员做的事情</h1><h1 id="多线程的优缺点"><a href="#多线程的优缺点" class="headerlink" title="多线程的优缺点"></a>多线程的优缺点</h1><pre><code>**优点**
*
*
**缺点**
*
*    pthread_cond_wait pthread_cond_signal
</code></pre>
<h1 id="多线程的同步方法"><a href="#多线程的同步方法" class="headerlink" title="多线程的同步方法"></a>多线程的同步方法</h1><h1 id="多进程的同步方法"><a href="#多进程的同步方法" class="headerlink" title="多进程的同步方法"></a>多进程的同步方法</h1><h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1><h1 id="binder-通信"><a href="#binder-通信" class="headerlink" title="binder 通信"></a>binder 通信</h1><h1 id="RPC-调用"><a href="#RPC-调用" class="headerlink" title="RPC 调用"></a>RPC 调用</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">mystrstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str,<span class="type">const</span> <span class="type">char</span> *substr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(str==<span class="literal">NULL</span>||substr==<span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;error NULL\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(str)&lt;<span class="built_in">strlen</span>(substr))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">char</span> *cp=str;</span><br><span class="line">	<span class="type">char</span> *subcp=substr;</span><br><span class="line">	<span class="keyword">while</span>(*cp)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(*cp &amp;&amp; *subcp &amp;&amp; !(*cp-*subcp))</span><br><span class="line">		&#123;</span><br><span class="line">			subcp++;</span><br><span class="line">		&#125;</span><br><span class="line">		cp++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>about tree</title>
    <url>/2021/08/24/about-tree/</url>
    <content><![CDATA[<p>树，二叉树，traverse<br>平衡二叉树<br>二分法查找<br>红黑树<br>逆波兰表示法<br>epoll的底层是 红黑树<br>poll 和select的底层是线性表</p>
]]></content>
      <tags>
        <tag>alogrithm</tag>
      </tags>
  </entry>
  <entry>
    <title>About UML</title>
    <url>/2020/02/02/about-uml/</url>
    <content><![CDATA[<h1 id="UML-是啥"><a href="#UML-是啥" class="headerlink" title="UML 是啥"></a>UML 是啥</h1><p>　　The Unified Modeling Language (UML) is a general-purpose, developmental, modeling language in the field of software engineering<br>that is intended to provide a standard way to visualize the design of a system.</p>
<h1 id="UML-中的十种图"><a href="#UML-中的十种图" class="headerlink" title="UML 中的十种图"></a>UML 中的十种图</h1><ul>
<li>静态模型图： 描述系统的静态结构<ul>
<li><strong>类图</strong></li>
<li>对象图</li>
<li>包图</li>
<li>组件图</li>
<li>部署图</li>
</ul>
</li>
<li>动态模型图： 描述系统行为的各个方面<ul>
<li><strong>用例图</strong></li>
<li><strong>时序图</strong></li>
<li><strong>活动图</strong></li>
<li>协作图</li>
<li>状态图</li>
</ul>
</li>
</ul>
<h1 id="UML-中的四种关系"><a href="#UML-中的四种关系" class="headerlink" title="UML 中的四种关系"></a>UML 中的四种关系</h1><ul>
<li><strong>关联关系(association)</strong></li>
<li><strong>依赖关系(dependency)</strong></li>
<li><strong>泛化关系(generalization)</strong></li>
<li><strong>实现关系(realization&#x2F;implementation)</strong></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>about-vim</title>
    <url>/2021/08/26/about-vim/</url>
    <content><![CDATA[<h1 id="本文章主要讲解vim的学习路径和常用配置及基本介绍和操作"><a href="#本文章主要讲解vim的学习路径和常用配置及基本介绍和操作" class="headerlink" title="本文章主要讲解vim的学习路径和常用配置及基本介绍和操作"></a>本文章主要讲解vim的学习路径和常用配置及基本介绍和操作</h1><h1 id="模式切换，此处的模式不一定是vim官方的叫法，主要是我自己的理解"><a href="#模式切换，此处的模式不一定是vim官方的叫法，主要是我自己的理解" class="headerlink" title="模式切换，此处的模式不一定是vim官方的叫法，主要是我自己的理解"></a>模式切换，此处的模式不一定是vim官方的叫法，主要是我自己的理解</h1><h2 id="浏览模式（只能使用hjkl进行上下左右光标切换）到编辑模式（可以输入字符）"><a href="#浏览模式（只能使用hjkl进行上下左右光标切换）到编辑模式（可以输入字符）" class="headerlink" title="浏览模式（只能使用hjkl进行上下左右光标切换）到编辑模式（可以输入字符）"></a>浏览模式（只能使用hjkl进行上下左右光标切换）到编辑模式（可以输入字符）</h2><p>   键盘上的小写字符（a,i,o)<br>   a（append)光标的后边位置加入字符<br>   i（insert)光标当前位置插入字符<br>   o (open) 在光标的下一行新插入一行空行<br>   键盘上的大写字符（A,I,O)<br>   A（Append)在行尾加入字符<br>   I（Insert)在行首插入字符<br>   O (Open) 在光标的上一行新插入一行空行</p>
<h2 id="退出任意-命令模式，编辑模式，列编辑模式-模式到浏览模式"><a href="#退出任意-命令模式，编辑模式，列编辑模式-模式到浏览模式" class="headerlink" title="退出任意(命令模式，编辑模式，列编辑模式)模式到浏览模式"></a>退出任意(命令模式，编辑模式，列编辑模式)模式到浏览模式</h2><p>   按键盘上的Esc键一次不行，按两次<br>　 ## 从浏览模式到命令模式，英文冒号<br>   ： wq(保存退出)</p>
<h2 id="浏览模式到行编辑模式"><a href="#浏览模式到行编辑模式" class="headerlink" title="浏览模式到行编辑模式"></a>浏览模式到行编辑模式</h2><ul>
<li>V (大写字母v)，可以选中多行进行批量操作<h2 id="浏览模式下其他不常用的命令"><a href="#浏览模式下其他不常用的命令" class="headerlink" title="浏览模式下其他不常用的命令"></a>浏览模式下其他不常用的命令</h2><pre><code>J(大写字母j)可以合并当前行和下一行，当前行的行尾和下一行的首部合并到当前行
</code></pre>
</li>
</ul>
<h1 id="命令模式的常用命令"><a href="#命令模式的常用命令" class="headerlink" title="命令模式的常用命令"></a>命令模式的常用命令</h1><h2 id="x-保存并退出"><a href="#x-保存并退出" class="headerlink" title="x (保存并退出)"></a>x (保存并退出)</h2><h2 id="q-没有编辑，直接退出"><a href="#q-没有编辑，直接退出" class="headerlink" title="q (没有编辑，直接退出)"></a>q (没有编辑，直接退出)</h2><h2 id="q-已经编辑了，放弃修改退出"><a href="#q-已经编辑了，放弃修改退出" class="headerlink" title="q! (已经编辑了，放弃修改退出)"></a>q! (已经编辑了，放弃修改退出)</h2><h2 id="w-把编辑内容从缓存写入磁盘文件，即存盘"><a href="#w-把编辑内容从缓存写入磁盘文件，即存盘" class="headerlink" title="w (把编辑内容从缓存写入磁盘文件，即存盘)"></a>w (把编辑内容从缓存写入磁盘文件，即存盘)</h2><h2 id="！ls-（执行shell命令ls"><a href="#！ls-（执行shell命令ls" class="headerlink" title="！ls  （执行shell命令ls)"></a>！ls  （执行shell命令ls)</h2><h1 id="vim-redo"><a href="#vim-redo" class="headerlink" title="vim redo"></a>vim redo</h1><p>ctrl + R</p>
<h1 id="学习vim的方法"><a href="#学习vim的方法" class="headerlink" title="学习vim的方法"></a>学习vim的方法</h1><ul>
<li>vimtutor </li>
<li>: help topic<h1 id="vim-打开没有权限的文件-忘记使用sudo打开-之后如何强制保存"><a href="#vim-打开没有权限的文件-忘记使用sudo打开-之后如何强制保存" class="headerlink" title="vim 打开没有权限的文件(忘记使用sudo打开) 之后如何强制保存"></a>vim 打开没有权限的文件(忘记使用sudo打开) 之后如何强制保存</h1>　　在vim的命令模式中输入:w !sudo tee %<h3 id="how-this-works-摘自stack-overflow"><a href="#how-this-works-摘自stack-overflow" class="headerlink" title="how this works 摘自stack overflow"></a>how this works 摘自<a href="https://stackoverflow.com/questions/2600783/how-does-the-vim-write-with-sudo-trick-work">stack overflow</a></h3><p>
in :w !sudo tee %...</li>
</ul>
<p>% means “the current file”<br>As eugene y pointed out, % does indeed mean “the current file name”, which is passed to tee so that it knows which file to overwrite.</p>
<p>(In substitution commands, it’s slightly different; as :help :% shows, it’s equal to 1,$ (the entire file) (thanks to @Orafu for pointing out that this does not evaluate to the filename). For example, :%s&#x2F;foo&#x2F;bar means “in the current file, replace occurrences of foo with bar.” If you highlight some text before typing :s, you’ll see that the highlighted lines take the place of % as your substitution range.)</p>
<p>:w isn’t updating your file<br>One confusing part of this trick is that you might think :w is modifying your file, but it isn’t. If you opened and modified file1.txt, then ran :w file2.txt, it would be a “save as”; file1.txt wouldn’t be modified, but the current buffer contents would be sent to file2.txt.</p>
<p>Instead of file2.txt, you can substitute a shell command to receive the buffer contents. For instance, :w !cat will just display the contents.</p>
<p>If Vim wasn’t run with sudo access, its :w can’t modify a protected file, but if it passes the buffer contents to the shell, a command in the shell can be run with sudo. In this case, we use tee.</p>
<p>Understanding tee<br><a href="https://stackoverflow.com/questions/2600783/how-does-the-vim-write-with-sudo-trick-work">https://stackoverflow.com/questions/2600783/how-does-the-vim-write-with-sudo-trick-work</a><br>As for tee, picture the tee command as a T-shaped pipe in a normal bash piping situation: it directs output to specified file(s) and also sends it to standard output, which can be captured by the next piped command.</p>
<p>For example, in ps -ax | tee processes.txt | grep ‘foo’, the list of processes will be written to a text file and passed along to grep.</p>
<pre><code> +-----------+    tee     +------------+
 |           |  --------  |            |
 | ps -ax    |  --------  | grep &#39;foo&#39; |
 |           |     ||     |            |
 +-----------+     ||     +------------+
                   ||   
           +---------------+
           |               |
           | processes.txt |
           |               |
           +---------------+
</code></pre>
<p>(Diagram created with Asciiflow.)</p>
<p>See the tee man page for more info.</p>
<p>Tee as a hack<br>In the situation your question describes, using tee is a hack because we’re ignoring half of what it does. sudo tee writes to our file and also sends the buffer contents to standard output, but we ignore standard output. We don’t need to pass anything to another piped command in this case; we’re just using tee as an alternate way of writing a file and so that we can call it with sudo.</p>
<p>Making this trick easy<br>You can add this to your .vimrc to make this trick easy-to-use: just type :w!!.</p>
<p>“ Allow saving of files as sudo when I forgot to start vim using sudo.<br>cmap w!! w !sudo tee &gt; &#x2F;dev&#x2F;null %<br>The &gt; &#x2F;dev&#x2F;null part explicitly throws away the standard output, since, as I said, we don’t need to pass anything to another piped command.</p>
</p>]]></content>
  </entry>
  <entry>
    <title>About virtualmachine</title>
    <url>/2020/02/18/about-vm/</url>
    <content><![CDATA[<h1 id="新建虚拟机的时候有磁盘类型选择"><a href="#新建虚拟机的时候有磁盘类型选择" class="headerlink" title="新建虚拟机的时候有磁盘类型选择"></a>新建虚拟机的时候有磁盘类型选择</h1><ul>
<li><p>IDE</p>
</li>
<li><p>SCSI(Recommended)</p>
</li>
<li><p>SATA</p>
</li>
<li><p>NVMe</p>
<h1 id="虚拟机文件磁盘类型"><a href="#虚拟机文件磁盘类型" class="headerlink" title="虚拟机文件磁盘类型"></a>虚拟机文件磁盘类型</h1></li>
<li><p>qcow2</p>
</li>
<li><p>raw</p>
</li>
<li><p>vhd</p>
</li>
<li><p>vmdk</p>
<h1 id="常见的虚拟机软件"><a href="#常见的虚拟机软件" class="headerlink" title="常见的虚拟机软件"></a>常见的虚拟机软件</h1></li>
<li><p>VMware Workstation </p>
</li>
<li><p>Oracle VM BOX</p>
</li>
<li><p>KVM(Kernel-based Virtual Machine)</p>
</li>
<li><p>Xen </p>
<h2 id="VMware虚拟机client是Linux遇到如果在Shell下输错命令或按TAB键补全命令系统会发出类似“嘟嘟-或-滴滴”的蜂鸣声"><a href="#VMware虚拟机client是Linux遇到如果在Shell下输错命令或按TAB键补全命令系统会发出类似“嘟嘟-或-滴滴”的蜂鸣声" class="headerlink" title="VMware虚拟机client是Linux遇到如果在Shell下输错命令或按TAB键补全命令系统会发出类似“嘟嘟 或 滴滴”的蜂鸣声"></a>VMware虚拟机client是Linux遇到如果在Shell下输错命令或按TAB键补全命令系统会发出类似“嘟嘟 或 滴滴”的蜂鸣声</h2><ol>
<li>编辑 &#x2F;etc&#x2F;inputrc设置 bell style 为none<br>set bell-style none</li>
<li>编辑 &#x2F;etc&#x2F;inputrc设置　用#注释掉下面两行<br>  set bell-style visible<br>  set bell-style audible</li>
<li>vmware 论坛有方案 将配置文件中的选项改为 mks.noBeep &#x3D; “TRUE”<p>
　　You can find the global configuration file at:</li>
</ol>
</li>
<li><p>Linux hosts:</p>
</li>
</ul>
<p>　　~&#x2F;.vmware&#x2F;config</p>
<ul>
<li>Windows 2000 and XP hosts:</li>
</ul>
<p>　　C:\Documents and Settings\All Users\Application Data\VMware\VMware_Product\config.ini</p>
<ul>
<li>Windows Vista, Windows 7, Windows 2008 Server R2, Windows 8, Windows 10 and Windows Server 2012 hosts:</li>
</ul>
<p>　　C:\ProgramData\VMWare\VMware_Product\config.ini <br><br>If the file does not exist, create a new text file and add the mks.noBeep line to it.</p>
</p>

]]></content>
      <tags>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>about-zypper</title>
    <url>/2021/08/26/about-zypper/</url>
    <content><![CDATA[<p>#cmd<br>zypper ar -c -t yast2 “iso:&#x2F;?iso&#x3D;&#x2F;home&#x2F;jaimin&#x2F;su1100.001.iso” “openSuSE 11”</p>
]]></content>
  </entry>
  <entry>
    <title>bash grammar cheatseet</title>
    <url>/2021/08/18/bash-grammar-cheatsheet/</url>
    <content><![CDATA[<h1 id="先贴一个bash中类似与c-中的switch-case的demo"><a href="#先贴一个bash中类似与c-中的switch-case的demo" class="headerlink" title="先贴一个bash中类似与c++ 中的switch case的demo"></a>先贴一个bash中类似与c++ 中的switch case的demo</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># switch.sh </span></span><br><span class="line"><span class="comment"># $# 代表使用这个脚本的时候给这个脚本传递的参数个数 -lt 代表 less than</span></span><br><span class="line"><span class="comment"># $0 代表脚本的名字， 和C语言main函数的argv[]参数类似</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -lt 1 ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$0</span> [sth] [sth]&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment"># $1 $2 $3 代表传给脚本的第几个参数</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -eq 2 ] &amp;&amp; [ <span class="variable">$2</span> == <span class="string">&quot;debug&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;this enter debug mode&quot;</span></span><br><span class="line">	DBG_FLAG=1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line">	x86)</span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;this is case x86&quot;</span></span><br><span class="line">	;;</span><br><span class="line">	arm32)</span><br><span class="line">	</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;this is case arm32&quot;</span></span><br><span class="line">    ;;</span><br><span class="line">	arm64)</span><br><span class="line">		<span class="built_in">echo</span> <span class="string">&quot;this is case arm64&quot;</span></span><br><span class="line">	;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算、原码、反码、补码</title>
    <url>/2020/02/18/bit-opteration/</url>
    <content><![CDATA[<h1 id="位运算的地位"><a href="#位运算的地位" class="headerlink" title="位运算的地位"></a>位运算的地位</h1><p>　以下内容摘自《枕边算法书》感觉对于位运算描述的很形象</p>
<blockquote>
<p>　　对于程序员来说,”位” 相当于现实世界中构成水和空气的粒子。<br>编程世界的所有东西都会从位开始，以位结束。刚步入编程世界的<br>初学者看到整数就是整数，看到字符串就是字符串。但功力深厚的<br>程序员眼中无论整数还是字符串，它们都是位。</p>
</blockquote>
<blockquote>
<p>　　与系统编程不同，一般应用程序的编程对位运算的要求并不高。<br>即使如此，很少有程序员不懂位运算，因为在不懂位运算的情况下<br>编程写程序，就像在现实世界中不呼吸、不喝水一样，几乎不可能。</p>
</blockquote>
<h1 id="位运算的类型"><a href="#位运算的类型" class="headerlink" title="位运算的类型"></a>位运算的类型</h1><table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">&amp;</td>
<td align="center">按位与:全1才1,否则都0</td>
</tr>
<tr>
<td align="center">|</td>
<td align="center">按位或:有1得1,全0才0</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">按位异或:相异为真,相同为假</td>
</tr>
<tr>
<td align="center">&gt;&gt;</td>
<td align="center">右移:对于有符号数的右移分为算术右移和逻辑右移</td>
</tr>
<tr>
<td align="center">&lt;&lt;</td>
<td align="center">左移:比较简单不论是否有符号整数</td>
</tr>
<tr>
<td align="center">~</td>
<td align="center">取反:每个位1变0,0变1</td>
</tr>
<tr>
<td align="center"><strong>对于正整数而言，左移1位就是x2,右移就是除2</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>下图来自《Computer Systems - A Programmer’s Perspective》</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><img src="https://i.loli.net/2020/02/23/PohLeXaVilHCFYq.png" alt="bit-right-shift.PNG"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">算术右移:直接右移n位,左侧空出来的n位全补0</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">逻辑右移:对于有符号数有些不同，对于无符号数没有区别</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">可惜对于右移而言标准c没有规定，应该使用哪种，大多数的编译器都使用算术右移</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">java中明确规定x&gt;&gt;k运算符表示x算术右移k位, x&gt;&gt;&gt;k表示逻辑右移</td>
<td align="center"></td>
</tr>
</tbody></table>
<h1 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h1><p>  一个数的二进制表示加上正负号</p>
<h1 id="反码-Ones’-complement-x2F-一的补码"><a href="#反码-Ones’-complement-x2F-一的补码" class="headerlink" title="反码(Ones’ complement &#x2F;一的补码)"></a>反码(Ones’ complement &#x2F;一的补码)</h1><p>定义<br><img src="https://i.loli.net/2020/02/22/6YB31Gx5nUwsVbv.png" alt="bit-fanma.png"><br>式中，N为真值，n为编码的位数</p>
<p>反码，正数的反码等于其原码，而负数的反码则可以通过保留其符号位，将原码的数值位取反得到。 </p>
<h1 id="补码-Twos’-complement-x2F-二的补码"><a href="#补码-Twos’-complement-x2F-二的补码" class="headerlink" title="补码(Twos’ complement &#x2F;二的补码)"></a>补码(Twos’ complement &#x2F;二的补码)</h1><p>　　<img src="https://i.loli.net/2020/02/23/qIiaTSh3ZgBfKoX.png" alt="bit-buma.PNG"><br>　　计算机中采用补码的原因是原码和反码的时候，0的表示不唯一</p>
<h1 id="补码的计算方法"><a href="#补码的计算方法" class="headerlink" title="补码的计算方法"></a>补码的计算方法</h1><p>　　正数的补码和原码一致，辅助的补码用用其绝对值的原码按位取反，然后(从LSB(最低有效位))+1</p>
<h1 id="根据补码-2补数-求真值的方法"><a href="#根据补码-2补数-求真值的方法" class="headerlink" title="根据补码(2补数)求真值的方法"></a>根据补码(2补数)求真值的方法</h1><p>　　设1100为补码, 拿到补码最高位是-(2^3), 然后 + 2^2 得到 -4 </p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>　　1. <strong>现代计算机中存储的永远是补码</strong><br>　　2. <strong>运算的时候也是用补码在运算</strong><br>　　3. <strong>x,y均为整数, 如果有~x &#x3D; y 成立,则有 x + y &#x3D; -1 成立</strong></p>
<h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><ol>
<li>~3 &#x3D; ？<br> 3 &#x3D; (0000 0011)按位取反得到(1111 1100) 按照2补数解释为-4</li>
<li><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cat = <span class="number">13</span>;</span><br><span class="line">cat - ~-cat; <span class="comment">// this experssion&#x27;s value is 1</span></span><br><span class="line"><span class="built_in">putchar</span> (~-~-~-cat); <span class="comment">// this line equal to putchar(&#x27;\n&#x27;); \n 的ascii code 十进制的值为 10</span></span><br></pre></td></tr></table></figure>
<h1 id="位运算可以用来判断整数的奇偶性"><a href="#位运算可以用来判断整数的奇偶性" class="headerlink" title="位运算可以用来判断整数的奇偶性"></a>位运算可以用来判断整数的奇偶性</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出0 ~ 100 的所有奇数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (i &amp; <span class="number">1</span>) &#123; <span class="comment">// 基数最低bit位是1</span></span><br><span class="line">    std::cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">std::cout&lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>busybox SUID support</title>
    <url>/2022/03/23/busybox-suid-support/</url>
    <content><![CDATA[<ul>
<li>开启 busybox对suid的支持<br><img src="https://img2022.cnblogs.com/blog/1523623/202203/1523623-20220321005945724-1384452418.png"></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">chmod</span> u+s /bin/busybox</span><br><span class="line">$ <span class="built_in">cat</span> /etc/busybox.conf</span><br><span class="line">[SUID]</span><br><span class="line"><span class="built_in">echo</span> = ssx root.root</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>C语言中数组</title>
    <url>/2020/02/16/c-array/</url>
    <content><![CDATA[<h1 id="数组的奇葩"><a href="#数组的奇葩" class="headerlink" title="数组的奇葩"></a>数组的奇葩</h1><p>  C语言中x[i]的计算方法 *(x + i)  x是个数组名，一般写数组的时候，x是常量指针,当x是0的时候没问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">is_big_endian</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0xbabe</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>[(<span class="type">unsigned</span> <span class="type">char</span> *)&amp;a] == <span class="number">0xbe</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i; <span class="comment">// 未初始化的全局变量，被初始化成0</span></span><br><span class="line"><span class="built_in">main</span> ()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// read 是自定义函数, read(0, i++ + &quot;hello, world!\n&quot;, 1); 实际上调用了系统调用write(1,指向hello, world!的指针，每次偏移一,1);</span></span><br><span class="line">  <span class="comment">// i[&quot;]&lt;i;++i)&#123;--i;&#125;&quot;] 是判断 *(&quot;]&lt;i;++i)&#123;--i;&quot;的地址 偏移 i) 是否为0，&quot;]&lt;i;++i)&#123;--i;&quot; 的长度和 &quot;hello, world!&quot;的长度一样</span></span><br><span class="line">  <span class="comment">// C语言中的字符串常量和数字做运算的时候是 常量指针const char *类型</span></span><br><span class="line">  <span class="keyword">for</span> (; i[<span class="string">&quot;]&lt;i;++i)&#123;--i;&#125;&quot;</span>]; <span class="built_in">read</span> (<span class="string">&#x27;-&#x27;</span> - <span class="string">&#x27;-&#x27;</span>, i++ + <span class="string">&quot;hello, world!\n&quot;</span>, <span class="string">&#x27;/&#x27;</span> / <span class="string">&#x27;/&#x27;</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">read</span> (j, i, p)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">write</span> (j / p + p, i-- - j, i / i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>C 语言中的main函数</title>
    <url>/2020/02/15/c-main/</url>
    <content><![CDATA[<h2 id="C语言中main写法"><a href="#C语言中main写法" class="headerlink" title="C语言中main写法"></a>C语言中main写法</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接受任意参数但不起作用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 明确不接受任何参数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// argc 参数的个数， argv 指向参数字符的首地址</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同上，第二个参数的不同写法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此版本可以打印出环境变量</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *env)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="关于main函数"><a href="#关于main函数" class="headerlink" title="关于main函数"></a>关于main函数</h2><ol>
<li>main函数并非必须存在，只是约定俗成的一个程序启动入口罢了,main函数被crt(C语言运行时)调用可以通过编译器指令来替换入口函数<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// entry.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">entry</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line"><span class="comment">//  return 0; // this will cause coredump ,因为程序直接entry 开始没有运行环境</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">// this works fine</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gcc -nostartfiles -e entry entry.c -o helloword</span><br><span class="line">$ ./helloword</span><br></pre></td></tr></table></figure></li>
<li>main 在c语言中还可以自己调用自己<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">    counter++;</span><br><span class="line">    <span class="built_in">main</span>();</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>main是个符号而已<br>1984年的IOCCC(International Obfuscated C Code Contest&#x2F;国际C代码混淆大赛)的两位牛人(Sjoerd Mullender</li>
</ol>
<p>Robbert van Renesse)通过下面的代码获得了特等奖The Grand Prize, 影响到后来的比赛规则，不鼓励写依赖硬件的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">short</span> main[] = &#123;</span><br><span class="line">	<span class="number">277</span>, <span class="number">04735</span>, <span class="number">-4129</span>, <span class="number">25</span>, <span class="number">0</span>, <span class="number">477</span>, <span class="number">1019</span>, <span class="number">0xbef</span>, <span class="number">0</span>, <span class="number">12800</span>,</span><br><span class="line">	<span class="number">-113</span>, <span class="number">21119</span>, <span class="number">0x52d7</span>, <span class="number">-1006</span>, <span class="number">-7151</span>, <span class="number">0</span>, <span class="number">0x4bc</span>, <span class="number">020004</span>,</span><br><span class="line">	<span class="number">14880</span>, <span class="number">10541</span>, <span class="number">2056</span>, <span class="number">04010</span>, <span class="number">4548</span>, <span class="number">3044</span>, <span class="number">-6716</span>, <span class="number">0x9</span>,</span><br><span class="line">	<span class="number">4407</span>, <span class="number">6</span>, <span class="number">5568</span>, <span class="number">1</span>, <span class="number">-30460</span>, <span class="number">0</span>, <span class="number">0x9</span>, <span class="number">5570</span>, <span class="number">512</span>, <span class="number">-30419</span>,</span><br><span class="line">	<span class="number">0x7e82</span>, <span class="number">0760</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">02400</span>, <span class="number">15</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">1280</span>, <span class="number">4</span>, <span class="number">0</span>,</span><br><span class="line">	<span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x8</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="string">&#x27;,&#x27;</span>, <span class="number">0</span>, <span class="number">12</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="string">&#x27;#&#x27;</span>,</span><br><span class="line">	<span class="number">0</span>, <span class="number">020</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>, <span class="number">026</span>, <span class="number">0</span>, <span class="number">0x6176</span>, <span class="number">120</span>, <span class="number">25712</span>,</span><br><span class="line">	<span class="string">&#x27;p&#x27;</span>, <span class="number">072163</span>, <span class="string">&#x27;r&#x27;</span>, <span class="number">29303</span>, <span class="number">29801</span>, <span class="string">&#x27;e&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="下面是裁判的评论"><a href="#下面是裁判的评论" class="headerlink" title="下面是裁判的评论"></a>下面是裁判的评论</h3><p>
Judges' comments:
Without question, this C program is the most obfuscated C program that has ever been received! Like all great contest entries, they result in a change of rules for the following year. To prevent a flood of similar programs, we requested that programs be non machine specific.

<p>This program was selected for the 1987 t-shirt collection.</p>
<p>NOTE: If your machine is not a Vax-11 or pdp-11, this program will not execute correctly. In later years, machine dependent code was discouraged.</p>
<p>The C startup routine (via crt0.o) transfers control to a location named main. In this case, main just happens to be in the data area. The array of shorts, which has been further obfuscated by use of different data types, just happens to form a meaningful set of PDP-11 and Vax instructions. The first word is a PDP-11 branch instruction that branches to the rest of the PDP code. On the Vax main is called with the calls instruction which uses the first word of the subroutine as a mask of registers to be saved. So on the Vax the first word can be anything. The real Vax code starts with the second word. This small program makes direct calls to the write() Unix system call to produce a message on the screen. Can you guess what is printed? We knew you couldn’t! :-)</p>
</p>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>cmd patchelf</title>
    <url>/2022/03/23/cmd-patchelf/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sudo zypper in -y patchelf</span></span><br><span class="line"><span class="comment"># patchelf 可以修改可执行文件的 使用的链接器</span></span><br><span class="line"><span class="comment"># It can change the dynamic loader (&quot;ELF interpreter&quot;) of the executables and change the RPATH of executables and libraries</span></span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>cmd sysctl</title>
    <url>/2022/03/23/cmd-sysctl/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入配置</span></span><br><span class="line">sudo sysctl -w fs.suid_dumpable=2</span><br><span class="line"><span class="comment"># 读取配置项</span></span><br><span class="line">sudo sysctl  fs.suid_dumpable</span><br><span class="line"><span class="comment"># 显示 所有的 可以配置的选项</span></span><br><span class="line">sudo sysctcl -a</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Linux capabilities 相关的命令</title>
    <url>/2022/03/23/cmds-about-linux-capabiltiys/</url>
    <content><![CDATA[<ul>
<li>可以通过一些命令设置 可执行文件的capabilities 或者查看进程或者文件的capabilites<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># opensuse 安装命令</span></span><br><span class="line">sudo zypper install  -y libcap-ng-utils libcap-progs</span><br><span class="line"><span class="comment"># debian 安装命令</span></span><br><span class="line">sudo apt install libcap2-bin libcap-ng-utils</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前有特殊capabilites的所有进程</span></span><br><span class="line">pscap -a</span><br></pre></td></tr></table></figure>
<img src="https://img2022.cnblogs.com/blog/1523623/202203/1523623-20220320231801303-557692776.png"></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看指定进程的capababilities</span></span><br><span class="line">getpcaps  1252</span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/1523623/202203/1523623-20220320231829321-341864005.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示文件系统中支持capabilities的 文件</span></span><br><span class="line">filecap</span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/1523623/202203/1523623-20220320231700675-913474523.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给 可执行文件赋予 capability</span></span><br><span class="line">sudo <span class="built_in">setcap</span>  <span class="string">&#x27;cap_net_admin,cap_sys_admin&#x27;</span>+eip /bin/busybox</span><br><span class="line">sudo <span class="built_in">setcap</span> <span class="string">&#x27;0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37&#x27;</span>+eip /bin/busybox</span><br><span class="line"><span class="comment"># 获取可执行文件的 capability</span></span><br><span class="line">sudo <span class="built_in">getcap</span> /usr/bin/cdrecord</span><br></pre></td></tr></table></figure>
<p><img src="https://img2022.cnblogs.com/blog/1523623/202203/1523623-20220320231953717-1924941323.png"></p>
]]></content>
  </entry>
  <entry>
    <title>Linux 下无法生成 coredump 文件</title>
    <url>/2022/03/23/coredump-file-fail2-produce/</url>
    <content><![CDATA[<ul>
<li><p>首先确认 linux内核配置支持了 coredump</p>
</li>
<li><p>然后 执行可执行文件的用户配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure></li>
<li><p>其次 确认配置了 &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;core_pattern 指定的生成core的路径，user 有写入权限</p>
</li>
<li><p>如果可执行文件 被chmod u+s 或者g+s 改过属性 或者setcap 添加过 capability 需要修改 节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 2 &gt; /proc/sys/fs/suid_dumpable</span><br></pre></td></tr></table></figure></li>
<li><p>配置 core_pattern</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 最简单的配置</span></span><br><span class="line"><span class="built_in">echo</span> /tmp/core_%e_%p &gt; /proc/sys/kernel/core_pattern</span><br><span class="line"><span class="comment"># 复杂一丢丢的</span></span><br><span class="line"><span class="built_in">echo</span> /core/core_%e_%p &gt; /proc/sys/kernel/core_pattern</span><br><span class="line"><span class="built_in">mkdir</span> -m 1777 /core</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个相关的网站</p>
<p> <a href="https://sysctl-explorer.net/fs/suid_dumpable/">https://sysctl-explorer.net/fs/suid_dumpable/</a></p>
</li>
<li><p>下方为man 5 core 的相关的摘要<br><img src="https://img2022.cnblogs.com/blog/1523623/202203/1523623-20220320234410267-1834205770.png"></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>keywords</title>
    <url>/2020/02/25/cpp-keywords/</url>
    <content><![CDATA[<h1 id="关键字与标识符"><a href="#关键字与标识符" class="headerlink" title="关键字与标识符"></a>关键字与标识符</h1><h1 id="经常考察的关键字"><a href="#经常考察的关键字" class="headerlink" title="经常考察的关键字"></a>经常考察的关键字</h1><ul>
<li>const *  常量 和指针一起 考察</li>
<li>voliate * 容易修改，禁止编译器优化，嵌入式，和多线程环境</li>
<li>extern * 外部引用，声明</li>
<li>static * 本文件，或者本函数可用，本类可用</li>
<li>auto * 自动变量、栈变量， 类型推导</li>
<li>register * 请求编译器将 变量放到寄存器<h1 id="不常见的关键字"><a href="#不常见的关键字" class="headerlink" title="不常见的关键字"></a>不常见的关键字</h1></li>
<li>restrict *</li>
</ul>
]]></content>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>debug-xp</title>
    <url>/2021/08/22/debug-xp/</url>
    <content><![CDATA[<h2 id="uboot-中启动httpd-服务的时候，使用浏览器无法打开升级网页，是因为浏览器默认启用了https"><a href="#uboot-中启动httpd-服务的时候，使用浏览器无法打开升级网页，是因为浏览器默认启用了https" class="headerlink" title="uboot 中启动httpd 服务的时候，使用浏览器无法打开升级网页，是因为浏览器默认启用了https,"></a>uboot 中启动httpd 服务的时候，使用浏览器无法打开升级网页，是因为浏览器默认启用了https,</h2><p>ubooot中的httpd 命令不支持 ssl加密 没有这个,所以用<a href="http://192.168.4.1/">http://192.168.4.1</a> 就能打开了</p>
<h2 id="mail-zowee-com-cn网站手机上打不开-电脑浏览器上能打开"><a href="#mail-zowee-com-cn网站手机上打不开-电脑浏览器上能打开" class="headerlink" title="mail.zowee.com.cn网站手机上打不开,电脑浏览器上能打开,"></a>mail.zowee.com.cn网站手机上打不开,电脑浏览器上能打开,</h2><p>因为手机上默认使用的http访问的,pc上默认使用了https访问</p>
]]></content>
  </entry>
  <entry>
    <title>sudo echo 3 &gt; /proc/sys/vm/drop_caches 权限不足</title>
    <url>/2022/03/23/drop-cache-no-permession/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以下命令可以解决 sudo 权限不够的问题</span></span><br><span class="line">sudo bash -c <span class="string">&quot;echo 3 &gt; /proc/sys/vm/drop_caches&quot;</span></span><br><span class="line"><span class="comment"># 以下命令也可以</span></span><br><span class="line">sudo sysctl -w vm.drop_caches=3</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式 bootargs mtd自动分区的设置</title>
    <url>/2022/03/23/embed-linux-bootargs-setup-and-mtd-autopartition/</url>
    <content><![CDATA[<ul>
<li><p>内核mtd子模块 需要开启 cmdline partition parse的支持<br><img src="https://img2022.cnblogs.com/blog/1523623/202203/1523623-20220320223605579-2042250006.png"></p>
</li>
<li><p>bootargs 要配置正确的分区表<br>&#96;&#96;&#96;bash<br>uboot#<br>setenv bootargs console&#x3D;ttyS0,115200 root&#x3D;&#x2F;dev&#x2F;mtdblock2 rootfstype&#x3D;jffs2  init&#x3D;&#x2F;init mem&#x3D;64M mtdparts&#x3D;spi0.0:704k(boot),2048k(kernel),2432k(rootfs),1664k(drv),-(app)<br>uboot#<br>sa<br>uboot#<br>reset</p>
</li>
<li></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>名词解释</title>
    <url>/2020/06/17/explain-words/</url>
    <content><![CDATA[<h1 id="ROM-BOOTROM-CD-ROM-RAM-SRAM-DRAM-SDRAM-DDR"><a href="#ROM-BOOTROM-CD-ROM-RAM-SRAM-DRAM-SDRAM-DDR" class="headerlink" title="ROM(BOOTROM CD-ROM) RAM(SRAM DRAM, SDRAM, DDR)"></a>ROM(BOOTROM CD-ROM) RAM(SRAM DRAM, SDRAM, DDR)</h1><h1 id="FLASH-NOR-NAND-FLASH"><a href="#FLASH-NOR-NAND-FLASH" class="headerlink" title="FLASH (NOR NAND FLASH)"></a>FLASH (NOR NAND FLASH)</h1><h1 id="SPI-SPL"><a href="#SPI-SPL" class="headerlink" title="SPI  SPL"></a>SPI  SPL</h1><p>uboot分为uboot-spl和uboot两个组成部分。SPL是Secondary Program Loader的简称，第二阶段程序加载器，这里所谓的第二阶段是相对于SOC中的BROM来说的，之前的文章已经有所介绍，SOC启动最先执行的是BROM中的固化程序。</p>
<p>BROM会通过检测启动方式来加载第二阶段bootloader。uboot已经是一个bootloader了，那么为什么还多一个uboot spl呢？</p>
<p>这个主要原因是对于一些SOC来说，它的内部SRAM可能会比较小，小到无法装载下一个完整的uboot镜像，那么就需要spl，它主要负责初始化外部RAM和环境，并加载真正的uboot镜像到外部RAM中来执行。</p>
<p>所以由此来看，SPL应该是一个非常小的loader程序，可以运行于SOC的内部SRAM中，它的主要功能就是加载真正的uboot并运行之</p>
<p>ARM SoC的启动过程：</p>
<p>RomBoot –&gt; SPL –&gt; u-boot –&gt; Linux kernel –&gt; file system –&gt; start application</p>
<p>(RomBoot是固化在SoC内部的。)</p>
<p>spl的产生：</p>
<p>因为芯片厂商固化的ROM支持从nandflash， SDCARD等外部介质启动，所以RomBoot会根据硬件电路的启动模式选择读取对应介质一小段数据到内存。BootRom读取多少才算合适呢？每个用户的需求不一样，大小也不能确定。很多芯片厂商干脆就只读4K&#x2F;8K&#x2F;16K等很小一段数据。这段数据你可以存放芯片初始化，读取介质数据到内存的工作是完全没有问题的。就这样在我们的软件界就产生了一个SPL概念，RomBoot读取这一小段代码就叫spl</p>
<h1 id="elf-x2F-bin"><a href="#elf-x2F-bin" class="headerlink" title="elf &#x2F; bin"></a>elf &#x2F; bin</h1><h1 id="objcopy用于将object的部分获全部内容拷贝到另一个object，从而可以实现格式的变换。"><a href="#objcopy用于将object的部分获全部内容拷贝到另一个object，从而可以实现格式的变换。" class="headerlink" title="objcopy用于将object的部分获全部内容拷贝到另一个object，从而可以实现格式的变换。"></a>objcopy用于将object的部分获全部内容拷贝到另一个object，从而可以实现格式的变换。</h1><p>Gcc 编译出来的是ELF文件。通常gcc –o test test.c,生成的test文件就是ELF格式的，在linuxshell下输入 .&#x2F;test就可以执行。</p>
<p>Bin 文件是经过压缩的可执行文件，去掉ELF格式的东西。是直接的内存映像的表示。在系统没有加载操作系统的时候可以执行。</p>
<p>elf（executable  and   link   format）文件里面包含了符号表，汇编等。<br>BIN文件是将elf文件中的代码段，数据段，还有一些自定义的段抽取出来做成的一个内存的镜像。</p>
<h1 id="xxxx-elf-objcopy-–O-binary-test-o-test-bin"><a href="#xxxx-elf-objcopy-–O-binary-test-o-test-bin" class="headerlink" title="xxxx-elf-objcopy –O binary test.o test.bin"></a>xxxx-elf-objcopy –O binary test.o test.bin</h1><h1 id="nor-vs-nand"><a href="#nor-vs-nand" class="headerlink" title="nor vs nand"></a>nor vs nand</h1><p>NOR FLASH 是很常见的一种存储芯片，数据掉电不会丢失。NOR FLASH 支持 Execute On Chip，即程序可以直接在 FLASH 片内执行。这点和 NAND FLASH 不一样。因此，在嵌入是系统中，NOR FLAS H 很适合作为启动程序的存储介质。NOR FLAS H 的读取和 RAM 很类似，但不可以直接进行写操作。对 NOR FLAS H 的写操作需要遵循特定的命令序列，最终由芯片内部的控制单元完成写操作。所以，NOR FLASH 一般是作为用于程序的存储与运行的工具。</p>
<p>NOR 的特点是芯片内执行(XIP， Execute In Place)，这样应用程序可以直接在 FLASH 闪存内运行，不必再把代码读到系统 RAM 中。NOR FLASH 的传输效率很高，在 1~4MB 的小容量时具有很高的成本效益，但是很低的写入和擦除速度大大影响了它的性能。</p>
<p>2NAND FLASH 与 NOR FLASH 的性能比较</p>
<p>FLASH 闪存是非易失存储器，可以对称为块的存储器单元块进行擦写和再编程。任何 FLASH 器件的写入操作只能在空或已擦除的单元内进行，所以大多数情况下，在进行写入操作之前必须先执行擦除。NAND FLASH 器件执行擦除操作是十分简单的，而 NOR FLASH 则要求在进行擦除前先要将目标块内所有的位都写为 0。</p>
<p>由于擦除 NOR FLASH 器件时是以 64～128KB 的块进行的，执行一个写入 &#x2F; 擦除操作的时间为 5s，与此相反，擦除 NAND FLASH 器件是以 8～32KB 的块进行的，执行相同的操作最多只需要 4ms。</p>
<p>执行擦除时块尺寸的不同进一步拉大了 NOR FLASH 和 NADN FLASH 之间的性能差距，统计表明，对于给定的一套写入操作(尤其是更新小文件时更多的擦除操作必须在基于 NOR FLASH 的单元中进行。</p>
<p>NAND FLASH 的单元尺寸几乎是 NOR FLASH 器件的一半，由于生产过程更为简单，NAND FLASH 结构可以在给定的模具尺寸内提供更高的容量，也就相应地降低了价格。</p>
<p>NOR FLASH 占据了容量为 1～16MB 闪存市场的大部分，而 NAND FLASH 只是用在 8～128MB 的产品当中，这也说明 NOR 主要应用在代码存储介质中，NAND FLASH 适合于数据存储，NAND FLASH 在 Compact Flash、Secure Digital、PC Cards 和 MMC 存储卡市场上所占份额最大</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>Application-Specific Integrated Circuit</p>
]]></content>
  </entry>
  <entry>
    <title>fast-power-algorithm</title>
    <url>/2021/08/17/fast-power-algorithm/</url>
    <content><![CDATA[<h1 id="快速幂算法，-先贴一下算法模板，后边研究好了再贴研究心得-还有什么矩阵的快速幂算法"><a href="#快速幂算法，-先贴一下算法模板，后边研究好了再贴研究心得-还有什么矩阵的快速幂算法" class="headerlink" title="快速幂算法， 先贴一下算法模板，后边研究好了再贴研究心得,还有什么矩阵的快速幂算法"></a>快速幂算法， 先贴一下算法模板，后边研究好了再贴研究心得,还有什么矩阵的快速幂算法</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fastpow</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (n) &#123;</span><br><span class="line">		<span class="keyword">if</span> (n&amp;<span class="number">1</span>) &#123;</span><br><span class="line">            ans *= base;</span><br><span class="line">		&#125;</span><br><span class="line">		base *= base;</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="直接幂算法，在数值比较大的时候，在做算法题目的时候，时间复杂度不能接受"><a href="#直接幂算法，在数值比较大的时候，在做算法题目的时候，时间复杂度不能接受" class="headerlink" title="直接幂算法，在数值比较大的时候，在做算法题目的时候，时间复杂度不能接受"></a>直接幂算法，在数值比较大的时候，在做算法题目的时候，时间复杂度不能接受</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">normalpow</span><span class="params">(<span class="type">int</span> base, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ans *= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>algorithm C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>git tricks</title>
    <url>/2022/03/23/git-tricks/</url>
    <content><![CDATA[<ul>
<li>git clone加速下载<br> 如果只需要最新的代码 不需要历史提交记录的时候可以 给git添加参数 –depth &#x3D;1<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/TheSuperPowerIsRich/OSX-KVM.git</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Hexo Quick Manual</title>
    <url>/2023/01/24/hexo-doc/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>kernel image formats</title>
    <url>/2022/03/23/kernel-img-formats/</url>
    <content><![CDATA[<ul>
<li>Image<br>the generic Linux kernel binary image file.</li>
<li>zImage<br>a compressed version of the Linux kernel image that is self-extracting.</li>
<li>uImage<br>an image file that has a U-Boot wrapper (installed by the mkimage utility) that includes the OS type and loader information.</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>kernel structs pos</title>
    <url>/2022/03/23/kernel-structs-pos/</url>
    <content><![CDATA[<ul>
<li><p>struct task_struct<br>sched.h</p>
</li>
<li><p>struct mm_struct<br>mm_types.h</p>
</li>
<li><p>current</p>
</li>
</ul>
<p>*struct cred<br>  cred.h</p>
]]></content>
  </entry>
  <entry>
    <title>Linux commands</title>
    <url>/2020/02/14/linux-cmd/</url>
    <content><![CDATA[<h1 id="linux-命令列表"><a href="#linux-命令列表" class="headerlink" title="linux 命令列表"></a>linux 命令列表</h1><ol>
<li><p>systemctl (Control the systemd system and service manager)</p>
<p> systemd 系统用来替代之前的linux 中的system V 目的在于统一系统服务,<br> 并行启动系统服务程序,加快系统启动,大部分现代linux使用此程序引导系统.<br> <strong>常用命令如下</strong></p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#    systemctl enable service_name</span></span><br><span class="line"><span class="comment">#    systemctl start service_name</span></span><br><span class="line"><span class="comment">#    systemctl status service_name</span></span><br><span class="line"><span class="comment">#    systemctl restart service_name</span></span><br><span class="line"><span class="comment">#    systemctl disable service_name</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>pushd  popd</li>
</ol>
<p>　　pushd dir_name 切换目录的同时把当前目录圧入栈,方便后续使用popd 弹出栈切换目录  </p>
<p>　　popd 弹出上一次的目录栈，相当于cd -<br>    popd 可以多次使用，直到目录栈为空，cd - 多次使用只会在两个目录之间来回切换</p>
<ol start="3">
<li><p>grep  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ grep -nrw getPower --include=<span class="string">&quot;*.h,*.c&quot;</span></span><br></pre></td></tr></table></figure>
<p>　　递归的查找当前目录中c文件和头文件，全词匹配 getPower -n 显示行号， -w 全词匹配 -r递归</p>
</li>
<li><p>sed(stream editor for filtering and transforming text)  </p>
<p> 流文本编辑器，执行格式匹配和替换 -i 输出到源文件</p>
</li>
<li><p>firewall-cmd 取代 ipfilter</p>
</li>
</ol>
<p>　　debian系的 可以通过sudo apt-get -y install firewalld安装<br>    * 开放端口<br>sudo firewall-cmd –permanent –add-port&#x3D;22444&#x2F;udp &amp;&amp; sudo firewall-cmd –permanent –add-port&#x3D;22444&#x2F;tcp &amp;&amp; sudo firewall-cmd –reload<br>    * 关闭端口<br>sudo firewall-cmd –permanent –remove-port&#x3D;22444&#x2F;udp &amp;&amp; sudo firewall-cmd –permanent –remove-port&#x3D;22444&#x2F;tcp &amp;&amp; sudo firewall-cmd –reload<br>    * 将80端口的流量转发至192.168.0.1的8080端口<br>sudo firewall-cmd –permanent –add-forward-port&#x3D;port&#x3D;80:proto&#x3D;tcp:toaddr&#x3D;192.168.0.1:toport&#x3D;8080<br>    *使防火墙规则生效 </br><br>    firewall-cmd –reload<br>    * 列出所有的防火墙规则 </br><br>    firewall-cmd  –list-all<br>    * 列出所有的防火墙允许通过的服务规则</br><br>    firewall-cmd –list-services<br>    * 列出所有的防火墙开放端口规则</br> firewall-cmd –list-ports<br>6. yum install python-pip python34-pip </br><br>　　centos 安装pip 管理python包</p>
<h2 id="cetnos-selinux-下开启-x2F-变更-ssh-端口"><a href="#cetnos-selinux-下开启-x2F-变更-ssh-端口" class="headerlink" title="cetnos selinux 下开启&#x2F;变更 ssh 端口"></a>cetnos selinux 下开启&#x2F;变更 ssh 端口</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum provides semanage 查询哪个软件包提供 semanage ,debian系的 用apt-cache search semanage</span></span><br><span class="line"><span class="comment"># yum -y install policycoreutils-python</span></span><br><span class="line"><span class="comment"># semanage port -a -t ssh_port_t -p tcp #PORTNUMBER</span></span><br></pre></td></tr></table></figure>
<h2 id="linux-安装-libsodium"><a href="#linux-安装-libsodium" class="headerlink" title="linux 安装 libsodium"></a>linux 安装 libsodium</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://download.libsodium.org/libsodium/releases/LATEST.tar.gz</span><br><span class="line">tar xfz LATEST.tar.gz &amp;&amp; <span class="built_in">cd</span> libsodium-stable/</span><br></pre></td></tr></table></figure>
<h2 id="centos-安装epel软件源"><a href="#centos-安装epel软件源" class="headerlink" title="centos 安装epel软件源"></a>centos 安装epel软件源</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum -y update &amp;&amp; yum -y install epel-release</span></span><br></pre></td></tr></table></figure>
<h2 id="opensuse-搜索软件组"><a href="#opensuse-搜索软件组" class="headerlink" title="opensuse 搜索软件组"></a>opensuse 搜索软件组</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zypper install -t pattern</span></span><br></pre></td></tr></table></figure>
<h2 id="opensuse-中文指导文档"><a href="#opensuse-中文指导文档" class="headerlink" title="opensuse 中文指导文档"></a>opensuse 中文指导文档</h2><p><a href="https://opensuse-guide.ustclug.org/srvlamp.php">文档链接</a></p>
<h2 id="查看linux运行级别"><a href="#查看linux运行级别" class="headerlink" title="查看linux运行级别"></a>查看linux运行级别</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">who</span> -r</span><br><span class="line">$ runlevel</span><br></pre></td></tr></table></figure>
<h2 id="查看linux的默认网关"><a href="#查看linux的默认网关" class="headerlink" title="查看linux的默认网关"></a>查看linux的默认网关</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ route -n</span><br><span class="line">$ netstat -nr</span><br></pre></td></tr></table></figure>
<h1 id="install-ssh"><a href="#install-ssh" class="headerlink" title="install ssh"></a>install ssh</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install ssh</span><br></pre></td></tr></table></figure>
<h1 id="install-man-pages"><a href="#install-man-pages" class="headerlink" title="install man pages"></a>install man pages</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install manpages-posix-dev</span><br><span class="line">apt-get install glibc-doc</span><br></pre></td></tr></table></figure>
<h1 id="install-git"><a href="#install-git" class="headerlink" title="install git"></a>install git</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install git-core gitk</span><br></pre></td></tr></table></figure>
<h1 id="install-build-essential"><a href="#install-build-essential" class="headerlink" title="install build-essential"></a>install build-essential</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">atp-get install build-essential gcc-doc</span><br></pre></td></tr></table></figure>
<h1 id="change-all-files-permession-current-dir"><a href="#change-all-files-permession-current-dir" class="headerlink" title="change all files permession  current dir"></a>change all files permession  current dir</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find ./ -<span class="built_in">type</span> d -<span class="built_in">exec</span> <span class="built_in">chmod</span> 644 &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<h1 id="change-all-dir-permession-in-current-dir"><a href="#change-all-dir-permession-in-current-dir" class="headerlink" title="change all dir permession in  current dir"></a>change all dir permession in  current dir</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find path -<span class="built_in">type</span> d -<span class="built_in">exec</span> <span class="built_in">chmod</span> 755 &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<h1 id="what-todo-whit-DHCP-timeout-is-taking-so-long"><a href="#what-todo-whit-DHCP-timeout-is-taking-so-long" class="headerlink" title="what todo whit DHCP timeout is taking so long."></a>what todo whit DHCP timeout is taking so long.</h1><p> Edit /etc&#x2F;sysconfig&#x2F;network&#x2F;dhcp and change the values for DHCLIENT_WAIT_AT_BOOT and DHCLIENT6 WAIT AT BOOT</p>
<h1 id="目录介绍"><a href="#目录介绍" class="headerlink" title="目录介绍"></a>目录介绍</h1><ol>
<li>/usr&#x2F;local&#x2F; 一般安装自己编译的软件</li>
<li>debian系的&#x2F;lib&#x2F;systemd&#x2F;system 目录下有各种service文件和系统运行级别的target文件</li>
<li>debian系的 /usr&#x2F;lib&#x2F;systemd&#x2F;usr&#x2F; 目录一般存放用户定义的service</li>
</ol>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux software commonly used</title>
    <url>/2021/08/07/linux-software-common-used/</url>
    <content><![CDATA[<h3 id="ubuntu-内核调试开发常用软件包名-记录"><a href="#ubuntu-内核调试开发常用软件包名-记录" class="headerlink" title="ubuntu 内核调试开发常用软件包名 记录"></a>ubuntu 内核调试开发常用软件包名 记录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">libncurses5-dev gcc-arm-linux-gnueabi build-essential gcc-5-arm-linux-gnueabi git libssl-dev openssl bc flex bison qemu make gdb gdb-multiarch \</span><br><span class="line">device-tree-compiler uml-utilities bridge-utils  nfs-kernel-server</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># openssl&#x27;s lib</span></span><br><span class="line">libssl-dev</span><br><span class="line"><span class="comment"># elf&#x27;s lib</span></span><br><span class="line">libelf-dev</span><br></pre></td></tr></table></figure>
<h2 id="内核启动的三种方式"><a href="#内核启动的三种方式" class="headerlink" title="内核启动的三种方式"></a>内核启动的三种方式</h2><ul>
<li>initrd （init ram disk）</li>
<li>init&#x3D; </li>
<li>root</li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux cmd (II)</title>
    <url>/2021/09/16/linuxcmd2/</url>
    <content><![CDATA[<h1 id="linux-cmd-1"><a href="#linux-cmd-1" class="headerlink" title="linux cmd 1"></a>linux cmd 1</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建 512M的空文件</span></span><br><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=./output.bin bs=1M count=512</span><br><span class="line"><span class="comment"># 创建 2M 的全为0xff的文件</span></span><br><span class="line"><span class="comment"># 命令, 用到了管道, 重定向操作,tr 命令用的比较少,这里用上了</span></span><br><span class="line"><span class="built_in">tr</span> <span class="string">&quot;\000&quot;</span> <span class="string">&quot;\377&quot;</span> &lt; /dev/zero | <span class="built_in">dd</span> of=./output.bin bs=1024 count=2048</span><br></pre></td></tr></table></figure>
<h1 id="mtd-闪存类-设备可以当作字符也可以当作块设备来操作根据dev下的设备名"><a href="#mtd-闪存类-设备可以当作字符也可以当作块设备来操作根据dev下的设备名" class="headerlink" title="mtd(闪存类) 设备可以当作字符也可以当作块设备来操作根据dev下的设备名"></a>mtd(闪存类) 设备可以当作字符也可以当作块设备来操作根据dev下的设备名</h1><h1 id="x2F-dev-x2F-mtd0-是字符设备-x2F-dev-x2F-mtdblock0-块设备"><a href="#x2F-dev-x2F-mtd0-是字符设备-x2F-dev-x2F-mtdblock0-块设备" class="headerlink" title="&#x2F;dev&#x2F;mtd0 是字符设备 &#x2F;dev&#x2F;mtdblock0 块设备"></a>&#x2F;dev&#x2F;mtd0 是字符设备 &#x2F;dev&#x2F;mtdblock0 块设备</h1><h1 id="可以直接cat-x2F-dev-x2F-mtd0-gt-mtd0-bin读出-使-echo-mtd0-bin-gt-x2F-dev-x2F-mtd0-写入"><a href="#可以直接cat-x2F-dev-x2F-mtd0-gt-mtd0-bin读出-使-echo-mtd0-bin-gt-x2F-dev-x2F-mtd0-写入" class="headerlink" title="可以直接cat &#x2F;dev&#x2F;mtd0&gt; mtd0.bin读出,使 echo mtd0.bin &gt;&#x2F;dev&#x2F;mtd0 写入"></a>可以直接cat &#x2F;dev&#x2F;mtd0&gt; mtd0.bin读出,使 echo mtd0.bin &gt;&#x2F;dev&#x2F;mtd0 写入</h1><h1 id="查看16进制"><a href="#查看16进制" class="headerlink" title="查看16进制"></a>查看16进制</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xxd output.bin |less</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>network protocol</title>
    <url>/2022/03/23/network-protocol/</url>
    <content><![CDATA[<ul>
<li>rtmp</li>
<li>srt</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>some tools</title>
    <url>/2022/03/23/some-tools/</url>
    <content><![CDATA[<ul>
<li>硬盘克隆软件<br>再生龙 (Clonezilla)<br><a href="https://clonezilla.org/">https://clonezilla.org/</a></li>
<li>文件恢复软件<br>Diskgenius<br><a href="https://www.diskgenius.com/">https://www.diskgenius.com/</a></li>
<li>系统启动盘软件<br>Ventoy 支持多个iso, 可以启动的时候选择iso镜像文件<br><a href="https://www.ventoy.net/en/index.html">https://www.ventoy.net/en/index.html</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>风言风语</title>
    <url>/2020/08/22/stupid-words/</url>
    <content><![CDATA[<h1 id="为什么选择租房的地方离公司近？"><a href="#为什么选择租房的地方离公司近？" class="headerlink" title="为什么选择租房的地方离公司近？"></a>为什么选择租房的地方离公司近？</h1><p>  不是为了多加班被资本压榨剩余价值，而是为了减少通勤时间，把时间用在睡觉和学习上来提升自己的竞争力</p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
  </entry>
  <entry>
    <title>windows 添加开机启动的位置</title>
    <url>/2022/03/23/win-setup-boot-with-system/</url>
    <content><![CDATA[<h1 id="widows-添加开机启动的方法"><a href="#widows-添加开机启动的方法" class="headerlink" title="widows 添加开机启动的方法"></a>widows 添加开机启动的方法</h1><ul>
<li>可以通过把可执行文件的快捷方式拖拽到  shell:startup 路径中实现开机启动<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">windows + R的运行窗口输入 shell:startup</span><br><span class="line"><span class="comment"># C:\Users\username\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span></span><br></pre></td></tr></table></figure>
ps: 注册表编辑器的名字 ,与标题无关<br>gpedit.msc</li>
</ul>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>windows 系统修复</title>
    <url>/2022/03/23/win-sys-fix-up/</url>
    <content><![CDATA[<ul>
<li>windows 修复<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sfc /SCANNOW </span><br><span class="line">rem  上一条命令发现问题才执行后续命令</span><br><span class="line">Dism /Online /Cleanup-Image /ScanHealth</span><br><span class="line">DISM /Online /Cleanup-image /RestoreHealth</span><br><span class="line">sfc /SCANNOW</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>windows 命令行 配置samba client</title>
    <url>/2022/03/23/windows-cmd-configure-samba-client/</url>
    <content><![CDATA[<ul>
<li>windows 命令行 配置samba<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">net use</span><br><span class="line"><span class="comment"># 查看所有 samba 连接</span></span><br><span class="line"></span><br><span class="line">net use /delete *</span><br><span class="line"><span class="comment"># 移除所有samba</span></span><br><span class="line">net use z: /delete</span><br><span class="line"><span class="comment"># 删除 z:盘映射</span></span><br><span class="line"></span><br><span class="line">net use z: \\192.168.28.22\wang  /user:username passwd</span><br><span class="line"><span class="comment"># 挂载samba共享为 z:盘</span></span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>windows 配置本地转发</title>
    <url>/2022/03/23/windows-configure-local-proxy/</url>
    <content><![CDATA[<ul>
<li>windows 配置本地转发<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">netsh interface portproxy add v4tov4 listenaddress=<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> listenport=<span class="number">445</span> connectaddress=<span class="number">114</span>.<span class="number">114</span>.<span class="number">114</span>.<span class="number">114</span> connectport=<span class="number">1445</span></span><br><span class="line"># 监听本地 到<span class="number">445</span>端口（samba)的 访问转发到 远端的 <span class="number">1445</span></span><br><span class="line"></span><br><span class="line">netsh interface portproxy delete v4tov4  listenaddress=<span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span> listenport=<span class="number">445</span> protocol=tcp</span><br><span class="line"># 删除本地转发规则</span><br><span class="line"></span><br><span class="line">netsh interface portproxy show v4tov4</span><br><span class="line">#显示本地转发规则</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
</search>
